<!DOCTYPE html>
<meta charset="utf-8">
<html>
<style>
body {
  font: 10px sans-serif;
}

.axis path, .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.area {
  fill: lightsteelblue;
}

.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.dot {
  fill: white;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.axistitle {
	font-size: 1.5em;
	font-weight:bold;
}

.title {
	font-size: 2em;
	font-weight:bold;
}
.link:hover {
    cursor:pointer
}
</style>
<body style="width:100px">
<!--  <script src="d3\d3.v2.js"></script> -->
<!--  <script src="https://raw.github.com/mbostock/d3/master/d3.v2.js"></script> -->
<script src="http://d3js.org/d3.v2.js"></script>


<script>

var start = new Date(),
    content = JSON.parse('$JSON'),
    json = content.list[0],
    bins = json.hist.bins,
    svgWidth, svgHeight,
    plotArea = {
        margin : "", 
        width : 0,
        height : 0},
    main; 
Plot = function(hist) {
    this.type = hist.type;
    this.x = {
        min : {
            id : 0,
            value: hist.xaxis.first.value
        },
        max : {
            id : hist.xaxis.last.id,
            value: hist.xaxis.last.value
        },
        customised : false,
        width : false,
        domain : {
            min : null,
            max : null
        },
        scale : null,
        bins: null
    };
    this.x.isInDomain = function(value) {
        return (value >= this.min.value && value <= this.max.value);
    }
    this.x.isWithinDomain = function(value) {
        return (value > this.min.value && value < this.max.value);
    }
    this.x.setScaleLimit = function(minId,maxId) {
        if(!this.scale)
            return;
        if(minId != null && maxId != null)
            if(maxId > minId) {
               this.scale.domain([this.bins.lowEdgeX(minId),this.bins.lowEdgeX(maxId)])
               this.min.value = this.bins.lowEdgeX(minId);
               this.max.value = this.bins.lowEdgeX(maxId);
               this.max.id = this.min.id + maxId;
               this.min.id += minId;
            }
        if(minId != null && maxId == null)
            if(this.max.id > this.min.id + minId) {
                this.scale.domain([this.bins.lowEdgeX(minId),this.max.value ])
                this.min.value = this.bins.lowEdgeX(minId);
                this.min.id += minId;
            }
        if(minId == null && maxId != null)
            if(this.min.id + maxId > this.min.id) {
                this.scale.domain([this.min.value , this.bins.lowEdgeX(maxId)])
                this.max.value = this.bins.lowEdgeX(maxId);
                this.max.id = this.min.id + maxId;
            }
    }
    if(isTH2(hist.type)) {
        this.y = {
            min : {
                id : 0,
                value: hist.yaxis.first.value
            },
            max : {
                id : hist.yaxis.last.id,
                value: hist.yaxis.last.value
            },
            customised : false,
            width : false,
            domain : {
                min : null,
                max : null
            },
            scale : null,
            bins: null
        };
        this.y.setScaleLimit = function(minId,maxId) {
            if(!this.scale)
                return;
            if(minId != null && maxId != null)
                if(maxId > minId) {
                   this.scale.domain([this.bins.lowEdgeY(minId),this.bins.lowEdgeY(maxId)])
                   this.min.value = this.bins.lowEdgeY(minId);
                   this.max.value = this.bins.lowEdgeY(maxId);
                   this.max.id = this.min.id + maxId;
                   this.min.id += minId;
                }
            if(minId != null && maxId == null)
                if(this.max.id > this.min.id + minId) {
                    this.scale.domain([this.bins.lowEdgeY(minId),this.max.value ])
                    this.min.value = this.bins.lowEdgeY(minId);
                    this.min.id += minId;
                }
            if(minId == null && maxId != null)
                if(this.min.id + maxId > this.min.id) {
                    this.scale.domain([this.min.value , this.bins.lowEdgeY(maxId)])
                    this.max.value = this.bins.lowEdgeY(maxId);
                    this.max.id = this.min.id + maxId;
                }
        }
    }
    else {
        this.y = {
        customised : false,
            domain : {
                min : null,
                max : null
            },
            scale : null
        }
        this.y.setScaleLimit = function(minId,maxId) {
            if(!this.scale)
                return;
            if(minId != null && maxId != null)
                if(maxId > minId) {
                   this.scale.domain([this.bins.lowEdgeY(minId),this.bins.lowEdgeY(maxId)])
                   this.min.value = this.bins.lowEdgeY(minId);
                   this.max.value = this.bins.lowEdgeY(maxId);
                   this.max.id = this.min.id + maxId;
                   this.min.id += minId;
                }
            if(minId != null && maxId == null)
                if(this.max.id > this.min.id + minId) {
                    this.scale.domain([this.bins.lowEdgeY(minId),this.max.value ])
                    this.min.value = this.bins.lowEdgeY(minId);
                    this.min.id += minId;
                }
            if(minId == null && maxId != null)
                if(this.min.id + maxId > this.min.id) {
                    this.scale.domain([this.min.value , this.bins.lowEdgeY(maxId)])
                    this.max.value = this.bins.lowEdgeY(maxId);
                    this.max.id = this.min.id + maxId;
                }
        }
        this.y.isInDomain = function(value) {
            return (value >= this.min.value && value <= this.max.value);
        }
        this.y.isWithinDomain = function(value) {
            return (value > this.min.value && value < this.max.value);
        }
    }
    this.w = null;
    this.h = null;
    Bins = function(plot, data) {
        this.plot = plot;
        this.defWidthX = null;
        this.defWidthY = null;
        this.getXBinBiggerOf= function (value) {
            for(var j=0; j!= this.xLen() ; ++j)
                if(this.lowEdgeX(j) > value) {
                    return j;
                }
            return this.plot.x.max.id-this.plot.x.min.id;
        }
        this.getXValueBiggerOf= function (value) {
            for(var j=0; j!= this.xLen() ; ++j)
                if(this.lowEdgeX(j) > value) {
                    return this.lowEdgeX(j);
                }
            return this.plot.x.max.value;
        }
        this.getXBinBiggerOrEqualOf= function (value) {
            for(var j=0; j!= this.plot.x.max.id-this.plot.x.min.id ; ++j)
                if(this.lowEdgeX(j) >= value)
                    return j;
            return this.plot.x.max.id-this.plot.x.min.id;
        }
        this.getYBinBiggerOf= function (value) {
            for(var j=0; j!= this.plot.y.max.id-this.plot.y.min.id ; ++j)
                if(this.lowEdgeY(j) > value)
                    return j;
            return this.plot.y.max.id-this.plot.y.min.id;
        }
        this.getYValueBiggerOf= function (value) {
            for(var j=0; j!= this.yLen() ; ++j)
                if(this.lowEdgeY(j) > value) {
                    return this.lowEdgeY(j);
                }
            return this.plot.y.max.value;
        }
        this.getYBinBiggerOrEqualOf= function (value) {
            for(var j=0; j!= this.plot.y.max.id-this.plot.y.min.id ; ++j)
                if(this.lowEdgeY(j) >= value)
                    return j;
            return this.plot.y.max.id-this.plot.y.min.id;
        }
        this.lowEdgeX = function (i) {
            if(data)
                if(data.lowEdgeX)
                    if(i == this.xLen())
                        return this.plot.x.max.value;
                    else
                        return data.lowEdgeX[this.plot.x.min.id+i];
                else
                    return plot.x.min.value + this.defWidthX*(this.plot.x.min.id+i);
        };
        this.lowEdgeY = function (i) {
            if(data && isTH2(plot.type))
                if(data.lowEdgeY)
                    if(i == this.yLen())
                        return this.plot.y.max.value;
                    else
                        return data.lowEdgeY[this.plot.y.min.id+i];
                else
                    return plot.y.min.value + this.defWidthY*(this.plot.y.min.id+i);
        };
        this.widthX = function (i) {
            if(data)
                if(data.lowEdgeX)
                    return this.lowEdgeX(i+1) - this.lowEdgeX(i); 
                else
                    return this.defWidthX;
        };
        this.widthY = function (i) {
            if(data && isTH2(plot.type))
                if(data.lowEdgeY)
                    return this.lowEdgeY(i+1) - this.lowEdgeY(i); 
                else
                    return this.defWidthY;
        };
        this.bins = function(i,j) {
            if(data && isTH1(plot.type))
                return this.data.content[this.plot.x.min.id+i];
            if(isTH2(plot.type))
                return this.data.content[this.plot.y.min.id+j][this.plot.x.min.id+i];
            return null;
        };
        this.xLen = function() {
            if(isTH1(plot.type))
                return this.data.content.length;
            if(isTH2(plot.type))
                return this.data.content[0].length;
            return null;
        };
        this.yLen = function() {
            if(isTH2(plot.type))
                return this.data.content.length;
            return null;
        };
        this.data = data
        this.tmp = "a";
    }
    this.bins = new Bins(this, hist.bins)
    this.x.bins = this.bins;
    this.y.bins = this.bins;
    var defWidthX,defWidthY;
    if(!hist.bins.lowEdgeX)
        this.bins.defWidthX = (hist.xaxis.last.value - hist.xaxis.first.value) / this.bins.xLen();   
    if(isTH2(hist.type) && !hist.bins.lowEdgeY)
        this.bins.defWidthY = (hist.yaxis.last.value - hist.yaxis.first.value) / this.bins.yLen();
}



function drawHist() {
    var vertMargin = Math.min(Math.max(svgHeight/10, 40), 60),
        horiMargin = Math.min(Math.max(svgWidth/10, 35), 60);
    plotArea.margin = {
        top: Math.min(Math.max(svgHeight/10, 20), 60),
        right: (isTH2(json.hist.type) ? horiMargin: 0), 
        bottom: vertMargin, 
        left: horiMargin
    };
    plot = new Plot(json.hist);
    main
    .attr("width", svgWidth)
    .attr("height", svgHeight)
 
    dx.minId = 0;
    dx.maxId = json.hist.xaxis.last.id; 
    if(json.hist.yaxis && json.hist.yaxis.last) {
        dy.minId = 0;
        dy.maxId = json.hist.yaxis.last.id;
    }
    
	drawTitleArea(json.hist)
	
	svg = main
	 	   .append("g")
	 	   .attr("transform", "translate(" + plotArea.margin.left + "," + plotArea.margin.top + ")");
    
	plotArea.width = svgWidth - plotArea.margin.left - plotArea.margin.right;
	plotArea.height = svgHeight - plotArea.margin.top - plotArea.margin.bottom;
/*	if(isTH2(json.hist.type)) {
	    nXbins = bins.content[0].length;
	    nYbins = bins.content.length;	    
	} else {
	    nXbins = bins.content.length;
	}*/
	drawAxis(json.hist, plot);
	
	if(isTH2(json.hist.type)) {
	    drawTH2bins(json.hist);
	} else {
	    drawTH1bins(json.hist);
	    if(content.list.length > 1) {
	        for(var i=1; i < content.list.length; ++i) {
	            var overlayHist = content.list[i].hist;
	            if(overlayHist.values.min != 0 || overlayHist.values.max != 0)
	                drawOverlay(json.hist, overlayHist, i, true)
	        }
	    } 
	}
	

	
	drawStats(json.hist);

	svg.attr("transform", "translate(" + plotArea.margin.left + "," + (plotArea.margin.top) + ")");

    var svgBox =  document.getElementsByTagName("svg")[0].getBBox();
    d3.select("content")
	 .style("width", svgBox.width+"px")
     .style("height", svgBox.height+"px")

     main.append("text")
      .attr("id","generatedIn")
      .text("generated in "+(new Date() - start)+" ms")
      .attr("x",0)
      .attr("y",svgHeight - 3)
      .attr("font-size","7px")
      .attr("font-family","Arial")
      .attr("dominant-baseline","auto")//hanging
//     alert(new Date() - start)
}
function isTProfile(type) {
    return (type == "TProfile")
}
function isTH1(type) {
    return (type == "TH1" || type == "TProfile")
}
function isTH2(type) {
    return (type == "TH2" || type == "TProfile2D")
}

function redraw(w,h) {
    start = new Date();
    d3.select("#content").remove()
    content = JSON.parse('$JSON');
    json = content.list[0];
    bins = json.hist.bins;
    plotArea = {
        margin : "", 
        width : 0,
        height : 0};
    main = d3.select("body").append("div")
     .attr("id","content")
     .append("svg");
    if(!w || !h)
        svgWidth = svgHeight = 500;
    else {
        svgWidth = w;
        svgHeight = h;
    }
    
    drawHist();
}
var xLabels, yLabels;
var nXbins, nYbins;
var x,y;
var svg;
var stats;
var dx = {min: 0, max: 0, minId: 0, maxId: 0}, 
    dy = {min: 0, max: 0, minId: 0, maxId: 0},
    dz = {min: 0, max: 0, minId: 0, maxId: 0};
var axisCustomised = {x: false, y: false, z: false};
var eps = 0.00001;

function drawTitleArea(hist) {
    var titleHeight = 0;
    if(hist.title) {
        var title = main.append("g")
            .attr("transform","translate(" + 0 + "," + 0 + ")")
            .attr("id","title")
         .append("text")
            .attr("class","title")
            .attr("dominant-baseline","hanging")
            .attr("text-anchor","begin")            
            .text(hist.title);
        for(var size=2; size>=0; size-=0.1) {
            var titleBox = document.getElementById("title").getBBox();
            if(titleBox.width < (svgWidth-100) && titleBox.height < plotArea.margin.top) {
                plotArea.margin.bottom += plotArea.margin.top - (titleBox.height + 5);
                plotArea.margin.top = titleBox.height + 5;
                break;
            }
            title.style("font-size", size+"em");            
        }
        titleHeight = document.getElementById("title").getBBox().height
        titleWidth = document.getElementById("title").getBBox().width
    } else {
        plotArea.margin.bottom += plotArea.margin.top - 10;
        plotArea.margin.top = 10;
    }
    var statsBoxWidth = 100;
    var statsLabel = 
            main.append("g")
             .attr("id", "stats")
             .attr("transform","translate(" + (svgWidth - statsBoxWidth) + "," + 0 + ")")
             .on("click",function() {
                 if(d3.select("#statsBox").attr("display") == "none")
                     d3.select("#statsBox").attr("display","block");
                 else
                     d3.select("#statsBox").attr("display","none");
             }) //
    statsLabel.append("rect")
        .attr("width",statsBoxWidth)
        .attr("height",titleHeight)
        .attr("fill","white")
        .attr("class","link")
//      .attr("stroke","black")
//      .attr("stroke-width", 2);
        
    statsLabel.append("text")
        .text("Stats")
        .attr("class","link")
        .attr("dominant-baseline","middle")
        .attr("text-anchor","middle")
        .attr("transform","translate("+statsBoxWidth/2+","+titleHeight/2+")");
}
function getLowEdge(hist,i) {
    if(hist.bins.lowEdge) {
        return hist.bins.lowEdge[i];
    } else {
        var defWidthX = (hist.xaxis.last.value - hist.xaxis.first.value)/nXbins;
        return hist.xaxis.first.value + defWidthX*i; 
    }
}
function getLowEdgeX(hist,i) {
    if(hist.bins.lowEdgeX) {
        return hist.bins.lowEdgeX[i];
    } else {
        var defWidthX = (hist.xaxis.last.value - hist.xaxis.first.value)/nXbins;
        return hist.xaxis.first.value + defWidthX*i; 
    }
}
function getLowEdgeY(hist,i) {
    if(hist.bins.lowEdgeY) {
        return hist.bins.lowEdgeY[i];
    } else {
        var defWidthY = (hist.yaxis.last.value - hist.yaxis.first.value)/nYbins;
        return hist.yaxis.first.value + defWidthY*i; 
    }
}

function drawXLabels(hist, x) {
    var gLabels = d3.select("#xaxisscale")
    var oldLabel = d3.select("#xaxisscale").select("text");
    d3.select("#xaxisscale")
         .selectAll("text").remove();
    var xAxisBox = document.getElementById("xaxis").getBBox();
    var labelsPosition =  (xAxisBox.y+ xAxisBox.height);
    xLabels = gLabels.selectAll(".label")
    .data(hist.xaxis.labels)
    .enter().append("text")
        .text(function(d) {return d.value;})
        .attr("class","label")
        .attr("text-anchor","middle")//begin
        .attr("dominant-baseline","hanging")//middle
        .attr("x", function(d){return x(d.center);})
        .attr("y", labelsPosition+5)
        .attr("fill",function(d){if(!plot.x.isInDomain(d.center)) {return "white"} else {return "black"}})
    
    for(var i = 1; i != gLabels.selectAll(".label")[0].length; ++i) {
        var firstLabel = gLabels.selectAll(".label")[0][i-1].getBBox();
        var secondLabel = gLabels.selectAll(".label")[0][i].getBBox();
        if(Math.abs(firstLabel.x + firstLabel.width) > Math.abs(secondLabel.x)) {
             gLabels.selectAll(".label").each(function() {
                 d3.select(this)
                  .attr("text-anchor","begin")
                  .attr("dominant-baseline","middle")                      
                  .attr("transform","translate("+0+","+0+") " +
                                "rotate("+90+" "+d3.select(this).attr("x")+",3"+")")
                  .attr("y", 3);
             })
             var xAxisBox = document.getElementById("xaxis").getBBox();
             if(xAxisBox.height > plotArea.margin.bottom) {
                 var yDelta = (xAxisBox.height - plotArea.margin.bottom) + 10;
                 plotArea.height -= yDelta;
                 plotArea.margin.bottom += yDelta;
                 d3.select("#xaxis")
                 .attr("transform", "translate(0," + (plotArea.height +1)+ ")")
             }
            break;
        }
    }
}
function  organiseXLabels() {
    var s = d3.format("s");
    d3.select("#xaxis").selectAll("text")
    .each(
        function(d,i) {
            if(d && d.toString().indexOf(".") != -1 && d.toString().length - d.toString().indexOf(".") > 3) {
                d3.select(this)
                .text( 
                    s(d.toFixed(d.toString().length-d.toString().indexOf(".")-2))
                )
            }
        }
    )
    for(var i = 1; i != d3.select("#xaxis").selectAll("text")[0].length-1; ++i) {
       x1 = d3.select("#xaxis").selectAll("text")[0][i-1];
       x2 = d3.select("#xaxis").selectAll("text")[0][i];
       if(!x1 || !x2)
           break;
       var matrix1 = x1.getTransformToElement(x1.nearestViewportElement);
       var matrix2 = x2.getTransformToElement(x2.nearestViewportElement);
        //p defaults to 0,0
        var p = x1.nearestViewportElement.createSVGPoint()
        var sp1 = p.matrixTransform(matrix1);
        var sp2 = p.matrixTransform(matrix2);
        if(sp1.x+ x1.getBBox().width>sp2.x) {
            d3.select("#xaxis").selectAll("text")
            .attr("text-anchor","start")
            .attr("dominant-baseline","middle")
            .attr("transform",function(d,i) {
                var width = d3.select("#xaxis").selectAll("text")[0][i].getBBox().height;
                return "translate("+width/2+",0) rotate(90 0,"+width/2+")";
            })
            break;
        }
    }
}
function checkDqmLimits(content, hist) {
    if(content.dqmInfo.xAxis.min != null || content.dqmInfo.xAxis.max != null) {
        if(content.dqmInfo.xAxis.min < json.hist.xaxis.first.value)
            content.dqmInfo.xAxis.min = null;
        if(content.dqmInfo.xAxis.min > json.hist.xaxis.last.value)
            content.dqmInfo.xAxis.min = null;
        if(content.dqmInfo.xAxis.max > json.hist.xaxis.last.value)
            content.dqmInfo.xAxis.max = null;
        if(content.dqmInfo.xAxis.max < json.hist.xaxis.first.value)
            content.dqmInfo.xAxis.max = null;
        if(content.dqmInfo.xAxis.min > content.dqmInfo.xAxis.max) {
            content.dqmInfo.xAxis.min = null;
            content.dqmInfo.xAxis.max = null;
        }
        if(content.dqmInfo.xAxis.type=="log" && content.dqmInfo.xAxis.max < 0)
            content.dqmInfo.xAxis.max = null;
    }
    if(content.dqmInfo.yAxis.min != null || content.dqmInfo.yAxis.max != null) {
        if(content.dqmInfo.yAxis.min > content.dqmInfo.yAxis.max) {
            content.dqmInfo.yAxis.min = null;
            content.dqmInfo.yAxis.max = null;
        }
        if(isTH2(hist.type)) {
            if(content.dqmInfo.yAxis.min < json.hist.yaxis.first.value)
                content.dqmInfo.yAxis.min = null;
            if(content.dqmInfo.yAxis.min > json.hist.yaxis.last.value)
                content.dqmInfo.yAxis.min = null;
            if(content.dqmInfo.yAxis.max > json.hist.yaxis.last.value)
                content.dqmInfo.yAxis.max = null;
            if(content.dqmInfo.yAxis.max < json.hist.yaxis.first.value)
                content.dqmInfo.yAxis.max = null;
            if(content.dqmInfo.yAxis.type=="log" && content.dqmInfo.yAxis.max < 0)
                content.dqmInfo.yAxis.max = null;
        }
    }
}
function drawAxis(hist, plot) {

    //quick fix... remove after changing width -> widthX for TH1 
    if(bins.width) 
        bins.widthX =bins.width;
    if(bins.lowEdgeX)
        bins.lowEdge = bins.lowEdgeX;
    // checking values od dqmInfo limits;
    checkDqmLimits(content, hist);
    
    if(content.dqmInfo.yAxis.max != null || content.dqmInfo.yAxis.min != null) {
        axisCustomised.y = true;
    }
    if(content.dqmInfo.xAxis.type=="log")
        x = d3.scale.log();
    else
        x = d3.scale.linear()
             .domain([ json.hist.xaxis.first.value, 
                json.hist.xaxis.last.value]);
    plot.x.scale = x;
    x.range([0, plotArea.width]);
    
    if(content.dqmInfo.xAxis.type=="log" && plot.x.min.value <= 0 && !(content.dqmInfo.xAxis.min > plot.bins.getXValueBiggerOf(0))) {
        var minId = plot.bins.getXBinBiggerOf(0)
        plot.x.setScaleLimit(minId,null);
    } else {
        if(content.dqmInfo.xAxis.min != null) {
            var minId = plot.bins.getXBinBiggerOf(content.dqmInfo.xAxis.min)
            plot.x.setScaleLimit(minId-1,null);
        }
    }
    if(content.dqmInfo.xAxis.max != null) {
        var maxId = plot.bins.getXBinBiggerOf(content.dqmInfo.xAxis.max)
        plot.x.setScaleLimit(null,maxId);
    }
    
    var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");
    if(isTH2(hist.type) && plot.x.max.id - plot.x.min.id < 10) 
        xAxis.ticks(plot.x.max.id - plot.x.min.id +1)
    if(hist.xaxis.labels) {
        xAxis.ticks(plot.x.max.id - plot.x.min.id);
    } else {
        xAxis.tickFormat(d3.format("s"));
    }
       
    var xAxisArea =
       svg.append("g")
        .attr("class", "x axis")
        .attr("id","xaxis");
    xAxisArea
     .append("g")
     .attr("id","xaxisscale")
     .call(xAxis);
    if(isTH1(hist.type)) 
        xAxisArea.attr("transform", "translate(0," + (plotArea.height)+ ")")
    else
        xAxisArea.attr("transform", "translate(0," + (plotArea.height +1)+ ")")
    if(hist.xaxis.labels) 
        drawXLabels(hist,x)  
    else 
        organiseXLabels()
   
        
    if(hist.xaxis.title) {
        var xAxisBox = document.getElementById("xaxis").getBBox();
        var xtitle = d3.select("#xaxis").append("text")
            .text(hist.xaxis.title)
            .attr("transform","translate("+(plotArea.width /*+ plotArea.margin.right*/)+", "+(xAxisBox.y+ xAxisBox.height)+")")
            .attr("text-anchor","end")
            .attr("dominant-baseline","hanging")            
            .attr("id","xtitle")            
            .attr("class","axistitle")
            .attr("x",0)
            .attr("y",0);
/*      for(var size=1.5; size>=0; size-=0.1) {
            ;
            if(document.getElementById("xtitle").getBBox().width < plotArea.width 
                    && document.getElementById("xaxis").getBBox().height < plotArea.margin.bottom)
                break;
            xtitle.style("font-size", size+"em");           
        }*/
    }
    
    dx.max = plot.x.max.value;
    dx.min = plot.x.min.value;
    dx.maxId = plot.x.max.id;
    dx.minId = plot.x.min.id;

    if(isTH2(hist.type)) {
        if(content.dqmInfo.yAxis.type=="log")
            y= d3.scale.log();
        else
            y= d3.scale.linear()
                 .domain([hist.yaxis.first.value
                     ,hist.yaxis.last.value]);
        plot.y.scale = y;
        y.range([plotArea.height, 0]);
       
        if(content.dqmInfo.yAxis.type=="log" && plot.y.min.value <= 0 && !(content.dqmInfo.yAxis.min > plot.bins.getXValueBiggerOf(0))) {
            var minId = plot.bins.getYBinBiggerOf(0)
            plot.y.setScaleLimit(minId,null);
        } else {
            if(content.dqmInfo.yAxis.min != null) { 
                var minId = plot.bins.getYBinBiggerOf(content.dqmInfo.yAxis.min)
                plot.y.setScaleLimit(minId-1,null);
            }
        }
        if(content.dqmInfo.yAxis.max != null) {
            var maxId = plot.bins.getYBinBiggerOf(content.dqmInfo.yAxis.max)
            plot.y.setScaleLimit(null,maxId);
        }
        dy.max = plot.y.max.value;
        dy.min = plot.y.min.value;
        dy.maxId = plot.y.max.id;
        dy.minId = plot.y.min.id;
    }    
    
    if(isTH1(hist.type)) {
        if(content.dqmInfo.yAxis.type=="log")
            y= d3.scale.log();
        else
            y= d3.scale.linear();
        y.domain([hist.values.min+0.00000001
                 ,hist.values.max])
         .range([plotArea.height, 0])
         .clamp(true);

        if(content.dqmInfo.yAxis.type=="log") {
            var min = hist.values.max;
            for(var i=0; i!= bins.content.length; ++i) {
                if(bins.content[i] > 0 && bins.content[i] < min)
                    min = bins.content[i];
            }
            y.domain([min, hist.values.max])
        } 
        
        
        if(!isTProfile(hist.type)) {   
            if(content.dqmInfo.yAxis.min != null || content.dqmInfo.yAxis.max != null) {
                if(content.dqmInfo.yAxis.min == null && content.dqmInfo.yAxis.max != null) {
                    content.dqmInfo.yAxis.min = hist.values.min;
                }
                if(content.dqmInfo.yAxis.max == null && content.dqmInfo.yAxis.min != null) {
                    content.dqmInfo.yAxis.max = hist.values.max;
                }
            }
        } else {
            if(axisCustomised.x && !axisCustomised.y) {
                var contentArray = bins.content,
                    errorArray = bins.error;
                var maxArray = [], minArray = [];
                contentArray = bins.content.slice(dx.minId, dx.maxId);
                errorArray = bins.error.slice(dx.minId, dx.maxId);
                if(content.dqmInfo.yAxis.type!="log")
                    for(var i=0; i!=contentArray.length; ++i) {
                        maxArray.push(contentArray[i]+errorArray[i]);
                        minArray.push(contentArray[i]-errorArray[i])
                    }
                else 
                    for(var i=0; i!=contentArray.length; ++i) {
                        maxArray.push(contentArray[i]+errorArray[i]);
                        if(contentArray[i]-errorArray[i] > 0)
                            minArray.push(contentArray[i]-errorArray[i])
                    }
                dy.min = d3.min(minArray);
                dy.max = d3.max(maxArray);
                y.domain([dy.min,dy.max]);
            }
            if(content.dqmInfo.yAxis.min != null || content.dqmInfo.yAxis.max != null) {
                if(content.dqmInfo.yAxis.min == null && content.dqmInfo.yAxis.max != null) {
                    content.dqmInfo.yAxis.min = dy.min;
                }
                if(content.dqmInfo.yAxis.max == null && content.dqmInfo.yAxis.min != null) {
                    content.dqmInfo.yAxis.max = dy.max;
                }
            }
        }
    }
    
    if((content.dqmInfo.yAxis.min != null|| content.dqmInfo.yAxis.max != null)) {
        axisCustomised.y = true;
        if(isTH1(hist.type)) {
            dy.min = content.dqmInfo.yAxis.min;
            dy.max = content.dqmInfo.yAxis.max;
            y.domain([dy.min,dy.max]);
        }
    }
    if(isTH1(hist.type) && !isTProfile(hist.type) && axisCustomised.x && !axisCustomised.y && content.dqmInfo.yAxis.type!="log") {
        dy.min = d3.min(bins.content.slice(dx.minId, dx.maxId));
        dy.max = d3.max(bins.content.slice(dx.minId, dx.maxId));
        y.domain([dy.min,dy.max]).nice();
    }
    if(isTH1(hist.type) && (content.dqmInfo.yAxis.type=="log" && !axisCustomised.y)) {
        y.nice()
        alert("TAK")
    }
    var yAxis = d3.svg.axis()
        .scale(y)
        .orient("left");
    if(isTH2(hist.type)  && dy.maxId - dy.minId < 10)
        yAxis.ticks(dy.maxId - dy.minId + 1)
    if(isTH2(hist.type) && hist.yaxis.labels) {
        yAxis.ticks(dy.maxId - dy.minId); 
    } else {
        yAxis.tickFormat(d3.format("s"));
    }
    var s = d3.format("s");
    var yAxisArea = svg.append("g")
        .attr("class", "y axis")
        .attr("id","yaxis")
    yAxisArea
    .append("g")
    .attr("id","yaxisscale")
    .call(yAxis);
    d3.select("#yaxis").selectAll("text")
    .each(
        function(d,i) {
            if(d && d.toString().indexOf(".") != -1 && d.toString().length - d.toString().indexOf(".") > 3) {
                d3.select(this)
                .text( 
                    s(d.toFixed(d.toString().length-d.toString().indexOf(".")-2))
                )
                
            }
        }
    )
    if(isTH2(hist.type))
        yAxisArea.attr("transform", "translate(-1,0)")
/*    if(isTH1(hist.type) && content.dqmInfo.yAxis.type == "log") {
        var logLabel = d3.select("#yaxisscale")
                .selectAll("text")[0];
        for(var i = 1; i < logLabel.length; ++i) {
            var firstLabel = logLabel[i-1].getBBox();
            var secondLabel = logLabel[i].getBBox();
            if(firstLabel.y + firstLabel.height > secondLabel.y) {
                d3.select("#yaxisscale")
                .selectAll("text").each(function(){
                    if(d3.select(this).text().toString()[0] != "1")
                        d3.select(this).style("display","none")
                })
                break;
            }
        }
    }*/
    if(isTH2(hist.type) &&  hist.yaxis.labels) {
        var gLabels = d3.select("#yaxisscale")
        d3.select("#yaxisscale")
             .selectAll("text").remove();
        var labelsPosition =  (document.getElementById("yaxisscale").getBBox().x);
        yLabels = gLabels.selectAll(".label")
        .data(hist.yaxis.labels)
        .enter().append("text")
            .text(function(d) {if(d.center < dy.max && d.center > dy.min) return d.value;})
            .attr("class","label")
            .attr("text-anchor","end")
            .attr("dominant-baseline","middle")         
            .attr("transform",function(d) {return "translate("+(labelsPosition-5)+","+y(d.center)+")"+" rotate(0)"});
    }    
    
    if(hist.yaxis && hist.yaxis.title) {
        var ytitle = d3.select("#yaxis").append("g").attr("id","gytitle").append("text")
            .text(hist.yaxis.title)
            .attr("transform","translate("+
                    (document.getElementById("yaxis").getBBox().x-5)+", 0)  rotate(-90)")
            .attr("text-anchor","end")
            .attr("dominant-baseline","auto")//hanging
            .attr("class","axistitle")
            .attr("id","ytitle")
            .attr("x",-10)
            .attr("y",0);
    }
    var yTitleSize = 1.5;
    var yLabelSize = 10;
    
    var titleBox = document.getElementById("title").getBBox();
    //try only 5 times to corect it if not possible leave it
    for (var i = 0; i<5 &&(document.getElementById("yaxis").getBBox().height > plotArea.height
            || document.getElementById("yaxis").getBBox().width > plotArea.margin.left); ++i) {
        if(hist.yaxis && hist.yaxis.title && document.getElementById("ytitle").getBBox().width > plotArea.height) {
            yTitleSize =yTitleSize*plotArea.height/document.getElementById("ytitle").getBBox().width - 0.05;
            ytitle.style("font-size", yTitleSize+"em");
        }
        if(document.getElementById("yaxis").getBBox().width > plotArea.margin.left) {
            yLabelSize =Math.round(yLabelSize*(plotArea.margin.left/document.getElementById("yaxis").getBBox().width - 0.05));
//          yLabels.style("font-size", yLabelSize+"px");
            d3.select("#yaxisscale").selectAll("text").style("font-size", yLabelSize+"px");
            if(ytitle) {
                yTitleSize -= 0.2; 
                ytitle.attr("transform","translate("+(document.getElementById("yaxisscale").getBBox().x)+", "+0+")  rotate(-90)")
                .style("font-size", yTitleSize+"em");
            }
        }
    }
    plotArea.margin.left = document.getElementById("yaxis").getBBox().width;
    
    var xTitleSize = 1.5;
    var xLabelSize = 10;
    var xTickSize = 6;
    var i;
    for (i = 0; i<5 &&(document.getElementById("xaxis").getBBox().width > plotArea.width
            || document.getElementById("xaxis").getBBox().height > plotArea.margin.bottom); ++i) {
        if(hist.xaxis.title && document.getElementById("xtitle").getBBox().width > plotArea.width) {
            xTitleSize =xTitleSize*plotArea.width/document.getElementById("xtitle").getBBox().width - 0.05;
            xtitle.style("font-size", xTitleSize+"em");
        }
        if(document.getElementById("xaxis").getBBox().height > plotArea.margin.bottom) {
            xLabelSize -= 1;
            xTickSize -= 0.5;
            d3.select("#xaxis").selectAll(".tick")
              .attr("y2",xTickSize);
            if(hist.xaxis.labels) {
                var labelsPosition =  (xAxisBox.y);
                xLabels
                 .style("font-size", xLabelSize+"px")
            } else
                d3.select("#xaxisscale").selectAll("text")
                 .style("font-size", xLabelSize+"px")
                 .attr("y",xTickSize+3);
            var xLabelBox = document.getElementById("xaxisscale").getBBox();
            if(xtitle) {
                xTitleSize -= 0.2; 
                xtitle
                 .attr("transform","translate("+(plotArea.width/*+ plotArea.margin.right*/)+", "+(xLabelBox.y+xLabelBox.height)+")")
                 .style("font-size", xTitleSize+"em");
            }
        }
    }
}
function colorOfNo(no) {
    switch(no) {
    case 0: return "black"
    case 1: return "blue"
    case 2: return "orange"
    case 3: return "red"
    case 4: return "violet"
    }
}
var errorArray2;
function drawOverlay(original, overlay, no, normalized) {
    if(normalized) {
//        var ratio = original.stats.sumOfWeights / overlay.stats.sumOfWeights;
        var ratio = 1
        var contentArray = overlay.bins.content.slice(dx.minId, dx.maxId);
        var errorArray = overlay.bins.error.slice(dx.minId, dx.maxId);
        errorArray2 = errorArray
        var plotArea = svg.append("g").attr("id","overlay "+ no);
        plotArea.selectAll(".point").data(stepBins).enter().append("circle")
        .attr("class","point")
        .attr("cx",function(d) {return x(d.x)})
        .attr("cy",function(d,i) {return y(contentArray[i] * ratio) })
        .attr("r",4)
        .attr("id",function(d,i) {return i})    
        .attr("fill",function(d,i) {if(y(contentArray[i] * ratio) == y.range()[0] || y(contentArray[i] * ratio) == y.range()[1]) {return "none"} else {return colorOfNo(no)};});

        
        plotArea.selectAll(".error").data(stepBins).enter().append("line")
        .attr("class","error")
        .attr("x1",function(d) {return x(d.x)})
        .attr("x2",function(d) {return x(d.x)})
        .attr("y1",function(d,i) {return y(((contentArray[i] -errorArray[i])* ratio)) })
        .attr("y2",function(d,i) {return y(((contentArray[i] +errorArray[i])* ratio)) })
//        .attr("y1",function(d,i) {return y(((contentArray[i] -d.error)* ratio)) })
//        .attr("y2",function(d,i) {return y(((contentArray[i] +d.error)* ratio)) })
//        .attr("y1",function(d,i) {return y((contentArray[i] * ratio)-d.error) })
//        .attr("y2",function(d,i) {return y((contentArray[i] * ratio)+d.error) })
        .attr("stroke",colorOfNo(no));
        
        plotArea.selectAll(".errorTop").data(stepBins).enter().append("line")
        .attr("class","errorTop")
        .attr("x1",function(d) {return x(d.x)-2})
        .attr("x2",function(d) {return x(d.x)+2})
        .attr("y1",function(d,i) {return y(((contentArray[i] +errorArray[i])* ratio)) })
        .attr("y2",function(d,i) {return y(((contentArray[i] +errorArray[i])* ratio)) })
//        .attr("y1",function(d,i) {return y(((contentArray[i] +d.error)* ratio)) })
//        .attr("y2",function(d,i) {return y(((contentArray[i] +d.error)* ratio)) })
//        .attr("y1",function(d,i) {return y((contentArray[i] * ratio)+d.error) })
//        .attr("y2",function(d,i) {return y((contentArray[i] * ratio)+d.error) })
        .attr("stroke",function(d,i) {if(errorArray[i] == 0 || y(((contentArray[i] +errorArray[i])* ratio)) == y.range()[1]) {return "none"} else {return colorOfNo(no)};});
        
        plotArea.selectAll(".errorBottom").data(stepBins).enter().append("line")
        .attr("class","errorBottom")
        .attr("x1",function(d) {return x(d.x)-2})
        .attr("x2",function(d) {return x(d.x)+2})
        .attr("y1",function(d,i) {return y(((contentArray[i] -errorArray[i])* ratio)) })
        .attr("y2",function(d,i) {return y(((contentArray[i] -errorArray[i])* ratio)) })       
//        .attr("y1",function(d,i) {return y(((contentArray[i] -d.error)* ratio)) })
//        .attr("y2",function(d,i) {return y(((contentArray[i] -d.error)* ratio)) })       
//        .attr("y1",function(d,i) {return y((contentArray[i] * ratio)-d.error) })
//        .attr("y2",function(d,i) {return y((contentArray[i] * ratio)-d.error) })
        .attr("id",function(d,i) {return i})
        .attr("stroke",function(d,i) {if(errorArray[i] == 0 || y(((contentArray[i] -errorArray[i])* ratio)) == y.range()[0]) {return "none"} else {return colorOfNo(no)};});
        
    } else {
        
    }
}
var errorArray,lowEdgeArray;
function drawTH1bins(hist) {
    var defWidth;
    if(!bins.width) {
        defWidth = (hist.xaxis.last.value - hist.xaxis.first.value)/bins.content.length;
    }
    stepBins = [];
    var width = bins.width;
    contentArray = bins.content;
    errorArray = bins.error;
    if(bins.width) {
        lowEdgeArray = bins.lowEdge;
        lowEdgeArray.push(hist.xaxis.last.value)
        lowEdgeArray =  lowEdgeArray.slice(dx.minId, dx.maxId+1);
    }   
    contentArray = contentArray.slice(dx.minId, dx.maxId);
    errorArray = errorArray.slice(dx.minId, dx.maxId);
    if(bins.width) {
        width = width.slice(dx.minId, dx.maxId);
    }

    var sumX;
    if(!bins.width) {
        sumX = dx.min + defWidth/2;
    } else {
        sumX = dx.min + width[0]/2;
    }
    
    var stepLabels = [];
    //limity!!!!!!!!!!!!!!!!!
    for(var i = 0; i!=contentArray.length; ++i) {
        var value = contentArray[i];
        
        var tmp = {};
        tmp.xOld = sumX;
        if((content.dqmInfo.yAxis.type=="log" && value <= 0) || (isTProfile(hist.type) && value == 0)) {
            tmp.y = y.domain()[0];
        } else {
            tmp.y = value;    
        }
        
        tmp.error = errorArray[i];
        if(!bins.width) {
            tmp.width = defWidth;
            tmp.x = x.domain()[0] + defWidth*i;
        } else {
            tmp.x = lowEdgeArray[i];
            tmp.width = lowEdgeArray[i+1] - lowEdgeArray[i];
            tmp.widthOld = width[i];
        }
        stepBins.push(tmp);

        if(bins.width) {
            sumX +=  width[i]/2
            if(i!=contentArray.length-1)
                sumX +=  width[i+1]/2;
    //            if(hist.xaxis.labels)
    //                stepLabels.push(sumX);
        } else {
            sumX += defWidth;
        }
 
    }
    var binsTable;
    var cells = svg 
        .append("g")
         .style("width", plotArea.width)
         .style("heigth", plotArea.heigth)
         
   
    cells.selectAll(".bin").data(stepBins).enter().append("line")
     .attr("class","bin")
     .attr("x1",function(d) {return x(d.x)})
     .attr("x2",function(d) {return x(d.x + d.width)})
     .attr("y1",function(d) {return y(d.y)})
     .attr("y2",function(d) {return y(d.y)})
     .attr("stroke",function(d) {if(y(d.y) == y(y.domain()[0]) || y(d.y) == y(y.domain()[1]) ) {return "none"} else {return "black"}})
     
    if(isTProfile(hist.type))
        cells.selectAll(".error").data(stepBins).enter().append("line")
         .attr("class","error")
         .attr("x1",function(d) {return x(d.x + d.width/2)})
         .attr("x2",function(d) {return x(d.x + d.width/2)})
         .attr("y1",function(d) {return y(d.y-d.error)})
         .attr("y2",function(d) {return y(d.y+d.error)})
         .attr("stroke","black")
     else {
         var lastVal = y.domain()[0];
         for(var i=0; i!=stepBins.length; ++i) {
             var d = stepBins[i];
             cells.append("line")
             .attr("class","vertical")
             .attr("x1",x(d.x))
             .attr("x2",x(d.x))
             .attr("y1",y(lastVal))
             .attr("y2",y(d.y))
             .attr("stroke","black")
             lastVal = d.y;
         }
         var d = stepBins[stepBins.length-1];
         cells.append("line")
         .attr("class","vertical")
         .attr("x1",x(d.x+d.width))
         .attr("x2",x(d.x+d.width))
         .attr("y1",y(lastVal))
         .attr("y2",y(y.domain()[0]))
         .attr("stroke","black")

     }
/*    cells.append("path")
        .attr("class", "area")
        .attr("d", area);

    cells.append("path")
        .attr("class", "line")
        .attr("d", line);*/
}
var stepsX, stepsY, contentArray,widthX, widthY ; 
var minVal, maxVal, z, maxOfCols , minOfCols;
var defWidthX, defWidthY,         defRectWidth, defRectHeight,
yDefWidth,xDefWidth;
function drawTH2bins(hist) {

    contentArray = bins.content;
    widthX = hist.bins.widthX;
    widthY = hist.bins.widthY;
    lowEdgeX = hist.bins.lowEdgeX;
    lowEdgeY = hist.bins.lowEdgeY;
    stepsX=[dx.min]; stepsY=[dy.min];   
    var sumX = hist.xaxis.first.value, sumY = hist.yaxis.first.value;

    if(bins.widthY) {
        sumY = dy.min;
        contentArray = contentArray.slice(dy.minId, dy.maxId);
        widthY = widthY.slice(dy.minId, dy.maxId);
        lowEdgeY.push(hist.yaxis.last.value)        
        lowEdgeY = lowEdgeY.slice(dy.minId, dy.maxId+1);
        nYbins = contentArray.length
        for(var i = 0; i!=nYbins; ++i) {
            sumY +=  widthY[i];
              stepsY.push(lowEdgeY[i])
        }
    } else {
        defWidthY = (hist.yaxis.last.value - hist.yaxis.first.value)/nYbins;
        defRectHeight = y(hist.yaxis.first.value)-y(hist.yaxis.first.value+defWidthY);
        if(axisCustomised.y) {
            var yMinId = (dy.min - hist.yaxis.first.value)/defWidthY;
            var yMaxId = (dy.max - hist.yaxis.first.value)/defWidthY;
            contentArray = contentArray.slice(dy.minId, dy.maxId);
            
            nYbins = contentArray.length;     
            yDefWidth = 
                d3.scale.linear()
                 .domain([0,(dy.max - dy.min)/defWidthY])
                 .range([plotArea.height-defRectHeight, -defRectHeight]);            
        } else {
            if(content.dqmInfo.yAxis.type=="log")
                yDefWidth = d3.scale.log();
            else
                yDefWidth = d3.scale.linear();
            yDefWidth
             .domain([0,(hist.yaxis.last.value- hist.yaxis.first.value)/defWidthY])
             .range([plotArea.height-defRectHeight, -defRectHeight]); 
        }
    }

    if(bins.widthX) {
        var xMinId = 0, xMaxId = nXbins;
        for(var i = 0; i!=nYbins; ++i) {
//            contentArray[i] = contentArray[i].slice(xMinId, xMaxId);
            contentArray[i] = contentArray[i].slice(dx.minId, dx.maxId);
        }
        widthX = widthX.slice(dx.minId, dx.maxId)
        lowEdgeX.push(hist.xaxis.last.value)   
        lowEdgeX = lowEdgeX.slice(dx.minId, dx.maxId+1)
        nXbins = contentArray[0].length
        sumX = dx.min;
        for(var i = 0; i!=nXbins; ++i) {
            sumX += widthX[i];
/*            if(axisCustomised.x && sumX < dx.min) {
                xMinId = i;
                continue;
            }*/            
//            stepsX.push(sumX);
            stepsX.push(lowEdgeX[i])
/*            if(axisCustomised.x && sumX > dx.max) {
                xMaxId = i+1;
                break;
            }*/
        }
    } else {
         defWidthX = (hist.xaxis.last.value - hist.xaxis.first.value)/nXbins;
         defRectWidth = x(hist.xaxis.first.value+defWidthX) - x(hist.xaxis.first.value)
         if(axisCustomised.x) {
//             var xMinId = (dx.min - hist.xaxis.first.value)/defWidthX;
//             var xMaxId = (dx.max - hist.xaxis.first.value)/defWidthX;
             for(var i = 0; i!=nYbins; ++i) {
                 contentArray[i] = contentArray[i].slice(dx.minId, dx.maxId);
             }
             nXbins = contentArray[0].length;
             xDefWidth =
                 d3.scale.linear()
                 .domain([0,(dx.max- dx.min)/defWidthX])
                 .range([0, plotArea.width]);             
         } else {
             if(content.dqmInfo.xAxis.type=="log")
                 xDefWidth = d3.scale.log()
             else
                 xDefWidth = d3.scale.linear()
             
            xDefWidth
             .domain([0.0000001,(hist.xaxis.last.value- hist.xaxis.first.value)/defWidthX]) 
             .range([0, plotArea.width]);
         }
     }
    
    
    minVal =  hist.values.min
    maxVal =  hist.values.max;
    if(axisCustomised.x || axisCustomised.y) {
        maxOfCols = []; minOfCols = [];
        for(var col = 0; col != contentArray.length; ++col) {
            
            maxOfCols.push(d3.max(contentArray[col]));
            minOfCols.push(d3.min(contentArray[col]));
        }
        minVal = d3.min(minOfCols);
        maxVal = d3.max(maxOfCols);
    }
    if(content.dqmInfo.zAxis.max != null || content.dqmInfo.zAxis.min != null ) {

        if(content.dqmInfo.zAxis.max != null && content.dqmInfo.zAxis.min != null ) {
            if(content.dqmInfo.zAxis.max > content.dqmInfo.zAxis.min) {
                minVal = content.dqmInfo.zAxis.min;
                maxVal = content.dqmInfo.zAxis.max;
            }
        } else {
            if(content.dqmInfo.zAxis.max != null) {
                if(content.dqmInfo.zAxis.max > minVal) {
                    maxVal = content.dqmInfo.zAxis.max;
                }
            }
            if(content.dqmInfo.zAxis.min != null) {
                if(content.dqmInfo.zAxis.min < maxVal) {
                    minVal = content.dqmInfo.zAxis.min;
                }
            }
        }
    }
        
    var range = (maxVal-minVal);
    z = d3.scale.linear()
       .domain([minVal, minVal+range/5, minVal+2*range/5, minVal+3*range/5, minVal+4*range/5,  maxVal])
       .range(["rgb(255,0,255)","rgb(0,0,255)","rgb(0,255,255)", "rgb(0,255,0)","rgb(255,255,0)", "rgb(255,0,0)"])
       .interpolate(d3.interpolateRgb);    
    
    var rects = svg
      .append("g")
       .attr("id","cells")
       .attr("width", plotArea.width)
       .attr("heigth", plotArea.heigth)
       .selectAll(".row")
       .data(contentArray)
       .enter()
      .append("g")
       .attr("id","row")
       .selectAll(".point")
       .data(function(d){return d;})
       .enter()
      .append("rect")
       .attr("id",function(d,i,j) {return "point"+i+j;})
       .style("fill",function(d,i,j) {if(d==0 || d<minVal) {return "rgb(255,255,255)";} else {if(d>maxVal) {return z(maxVal)} else {return z(d);}}});
    if(bins.widthX)
        rects
         .attr("x",function(d,i,j) {return x(lowEdgeX[i]);})
         .attr("width",function(d,i,j) {return x(lowEdgeX[i+1])-x(lowEdgeX[i]);})
    else 
        if(content.dqmInfo.xAxis.type=="log")
            rects
            .attr("x",function(d,i,j) {return x(defWidthX*i+ dx.min);})
            .attr("width",function(d,i,j) {return x(defWidthX*(i+1)+ dx.min)-x(defWidthX*i+ dx.min)})
        else
            rects
             .attr("x",function(d,i,j) {return xDefWidth(i);})
             .attr("width",defRectWidth)
        
        
    if(bins.widthY)
        rects
         .attr("y",function(d,i,j) {return y(lowEdgeY[j+1]);})
         .attr("height",function(d,i,j) {return y(lowEdgeY[j])-y(lowEdgeY[j+1]);})
    else
        if(content.dqmInfo.yAxis.type=="log")
            rects
            .attr("y",function(d,i,j) {return y(defWidthY*(j+1)+ dy.min);})
            .attr("height",function(d,i,j) {return y(defWidthY*j+ dy.min)-y(defWidthY*(j+1)+ dy.min)})
        else
            rects
            .attr("y",function(d,i,j) {return yDefWidth(j);})
            .attr("height",defRectHeight)


    var cells = document.getElementById("cells").getBBox();
    if(maxVal != minVal) {
        var values = d3.range(maxVal, minVal, (minVal-maxVal)/200);
        var xx = d3.scale.ordinal()
           .domain(values)
           .rangeBands([0,cells.height],0);
        
        svg.append("g")
         .attr("id","zaxis")
         .selectAll("rect")
           .data(values)
         .enter().append("rect")
            .attr("x", cells.x + cells.width + 1)
            .attr("y", xx)
            .attr("height", xx.rangeBand())
            .attr("width", plotArea.margin.right * 0.3)
            .style("fill", z)
           
        var zz = d3.scale.linear()
           .domain([maxVal, minVal])
           .range([0,cells.height]);
        
        var zAxis = d3.svg.axis()
            .scale(zz)
            .tickSize(10)
            .orient("right")
            .tickFormat(d3.format("s"));
        var zAxisBox = document.getElementById("zaxis").getBBox();
        
        d3.select("#zaxis").append("g")
            .attr("class", "z axis")
            .attr("transform", "translate("+(zAxisBox.x+zAxisBox.width)+",0)")
            .attr("id","zaxis")
            .call(zAxis);
        
        var zTitleSize = 1.5;
        var zLabelSize = 10;
        var zTicksLane = 10;
        var i;
        for (i = 0; i<5 && document.getElementById("zaxis").getBBox().width > plotArea.margin.right; ++i) {
            zLabelSize--;
            d3.select("#zaxis").selectAll("text")
              .style("font-size", zLabelSize+"px")
              .attr("x",zLabelSize+3);
            d3.select("#zaxis").selectAll(".tick")
              .attr("x2",zLabelSize)
        }
    }
}
 ;
function drawStats(hist) {
    var titleBox = document.getElementById("title").getBBox();  
    var statsBoxWidth = 150, statsBoxHeight = 220; 
    var statsBox = 
        main.append("g")
         .attr("id","statsBox")
         .attr("transform","translate(" + (svgWidth - statsBoxWidth) + "," + plotArea.margin.top + ")")
         .attr("display","none");
    var mainHistStats =  
        statsBox.append("g")
            .attr("id", "mainHistStats")
            .attr("transform","translate(0,18)");
    drawStatsBox(hist, mainHistStats,statsBoxWidth,0)
    if(isTH1(hist.type)) {
        var statsBoxSize = document.getElementById("mainHistStats").getBBox();
        var deltaY = 18;
        for(var i=1; i < content.list.length; ++i) {
            deltaY += statsBoxSize.height;
            var overlayHist = content.list[i].hist;
            var mainHistStats =  
                statsBox.append("g")
                    .attr("id", "histStats"+i)
                    .attr("transform","translate(0,"+(deltaY)+")");
            drawStatsBox(overlayHist, mainHistStats,statsBoxWidth,i)
            statsBoxSize = document.getElementById("histStats"+i).getBBox();
        }    
    }
    statsBox.append("text")
        .text("X ")
        .attr("dominant-baseline","hanging")
        .attr("text-anchor","end")
        .attr("font-weight", "bold")
        .attr("font-size",15)
        .attr("transform","translate("+(statsBoxWidth-2)+","+2+")")
        .attr("class","link")
        .on("click",function() {d3.select("#statsBox").attr("display","none")});

    
 
}

function drawStatsBox(hist, statsBox, statsBoxWidth, no) {
    var statsRect = statsBox.append("rect")
        .attr("width",statsBoxWidth)
        .attr("height",10)
        .attr("fill","white")
        .attr("stroke","black")
        .attr("stroke-width", 2);

    var statsNames = statsBox.append("text")
        .attr("id", "statsNames")
        .attr("font-weight", "bold")
        .attr("transform","translate("+(2)+","+0+")")
        .attr("fill",colorOfNo(no));
    var statsVals = statsBox.append("text")
        .attr("id", "statsVals")
        .attr("fill",colorOfNo(no))
        .attr("transform","translate("+(2)+","+0+")")
    for(var k in hist.stats) {
        statsNames
        .append("tspan")
         .attr("dy",15).attr("x",0)
         .text(k);        
        if( typeof hist.stats[k] != "object") {
           statsVals
            .append("tspan")
    //        .attr("transform","translate("+(statsBoxWidth-2)+","+20+")")
            .attr("text-anchor","end")
            .attr("dy",15).attr("x",statsBoxWidth-5)
            .text(hist.stats[k]);
        } else {
            var wasObj = true;
            for(var axis in hist.stats[k]) {
                if(!wasObj) {
                    statsNames
                    .append("tspan")
                     .attr("dy",15).attr("x",0)
                     .text(" ");
                }
                wasObj = false;
                statsNames
                .append("tspan")
                 .attr("x",32)
                 .text(axis);
                var wasSubObj = true;                
                for(var vals in hist.stats[k][axis]) {
                    if(!wasSubObj) {
                        statsNames
                        .append("tspan")
                         .attr("dy",15).attr("x",0)
                         .text(" ");
                    }
                    wasSubObj = false;
                    statsNames
                    .append("tspan")
                     .attr("x",45)
                     .text(vals);
                    
                    statsVals
                    .append("tspan")
        //            .attr("transform","translate("+(statsBoxWidth-2)+","+20+")")
                    .attr("text-anchor","end")
                    .attr("dy",15).attr("x",statsBoxWidth-5)
                    .text(hist.stats[k][axis][vals]);
                }
            }
        }
        statsNamesBox = document.getElementById(statsBox.attr("id")).getBBox();
        statsBoxHeight= statsNamesBox.y+statsNamesBox.height;

       
        var xDelta = 0; 
        var statsValsBox = document.getElementById("statsVals").getBBox();
          
        if(statsNamesBox.x > statsValsBox.x) {
            xDelta = statsValsBox.x - 30;
        } else {
            if(statsNamesBox.x + 30 > statsValsBox.x) {
                xDelta = (statsNamesBox.x - 30);
            }
        }
        if (xDelta != 0) {
            statsRect.attr("x", xDelta )
                     .attr("width", statsBoxWidth + Math.abs(xDelta));
            statsNames.attr("transform", "translate("+(xDelta + 2)+ ",18)");
        }
        statsRect.attr("height", statsBoxHeight+2);
    }
    
    var statsNamesBox = document.getElementById("statsNames").getBBox();
    var statsBoxHeight= statsNamesBox.y + statsNamesBox.height+18;
    if(isTH2(hist.type)) {
        statsNames
        .append("tspan")
         .attr("dy",15).attr("x",0)
         .text("integral");
        statsNamesBox = document.getElementById("statsNames").getBBox();
        statsBoxHeight= statsNamesBox.y + statsNamesBox.height+18;
        var pos = 0;
    
        var integral = 
                statsBox
                 .append("g")
                 .attr("id","integral");
        var integralRow1 =
                integral
                 .append("text")
                 .attr("text-anchor","end")
                 .attr("transform","translate("+(statsBoxWidth-5)+","+statsBoxHeight+")");
        
        var integralRow2 =             
                integral
                 .append("text")
                 .attr("text-anchor","end")
                 .attr("transform","translate("+(statsBoxWidth-5)+","+(statsBoxHeight+15)+")");
        
        var integralRow3 = 
                integral
                 .append("text")
                 .attr("text-anchor","end")
                 .attr("transform","translate("+(statsBoxWidth-5)+","+(statsBoxHeight+30)+")");
        var pos = 0;
        for(var i = 2 ; i!= -1 ; --i) {
            integralRow1 
            .append("tspan")
            .attr("x", pos)
            .text(bins.integral[0][i]);
            
            integralRow2 
             .append("tspan")
            .attr("x", pos)
             .text(bins.integral[1][i]);
             
            integralRow3 
            .append("tspan")
            .attr("x", pos)
            .text(bins.integral[2][i]);
            
            pos = -(document.getElementById("integral").getBBox().width+10);
        }
        statsRect.attr("height", statsBoxHeight+2+document.getElementById("integral").getBBox().height);
    }
}









 if(parent && parent.GUI) {
	 var extWin = parent.GUI.Plugin.DQMCanvas.getJsonWin();
	 svgWidth = extWin.getInnerWidth()-20/**0.95*/; svgHeight  =  extWin.getInnerHeight()-20/**0.95*/;
 } else {
	 svgWidth = svgHeight = 500;
 }
 main= d3.select("body")
     .append("div")
     .attr("id","content")
     .append("svg")

 if(json.hist.type == "TH2" 
     || json.hist.type == "TProfile2D" 
     || json.hist.type == "TH1" 
     || json.hist.type == "TProfile")
 {
		drawHist();
 }
  			
</script>
</body>
</html>

