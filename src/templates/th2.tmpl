<!DOCTYPE html>
<meta charset="utf-8">
<html>
<style>
body {
  font: 10px sans-serif;
}

.axis path, .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.area {
  fill: lightsteelblue;
}

.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.dot {
  fill: white;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.axistitle {
	font-size: 1.5em;
	font-weight:bold;
}

.title {
	font-size: 2em;
	font-weight:bold;
}
.link:hover {
    cursor:pointer
}
</style>
<body style="width:100px">
<!--  <script src="d3\d3.v2.js"></script> -->
<!--  <script src="https://raw.github.com/mbostock/d3/master/d3.v2.js"></script> -->
<script src="http://d3js.org/d3.v2.js"></script>


<script>

var start = new Date(),
    content = JSON.parse('$JSON'),
    json = content.list[0],
    bins = json.hist.bins,
    svgWidth, svgHeight,
    plotArea = {
        margin : "", 
        width : 0,
        height : 0},
    main; 

function drawHist() {
    var vertMargin = Math.min(Math.max(svgHeight/10, 40), 60),
        horiMargin = Math.min(Math.max(svgWidth/10, 35), 60);
    plotArea.margin = {
        top: Math.min(Math.max(svgHeight/10, 20), 60),
        right: (isTH2(json.hist.type) ? horiMargin: 0), 
        bottom: vertMargin, 
        left: horiMargin
    };
  
    main
    .attr("width", svgWidth)
    .attr("height", svgHeight)
 
    dx.minId = 0;
    dx.maxId = json.hist.xaxis.last.id; 
    if(json.hist.yaxis) {
        dy.minId = 0;
        dy.maxId = json.hist.yaxis.last.id;
    }
    
	drawTitleArea(json.hist)
	
	svg = main
	 	   .append("g")
	 	   .attr("transform", "translate(" + plotArea.margin.left + "," + plotArea.margin.top + ")");
    
	plotArea.width = svgWidth - plotArea.margin.left - plotArea.margin.right;
	plotArea.height = svgHeight - plotArea.margin.top - plotArea.margin.bottom;
	if(isTH2(json.hist.type)) {
	    nXbins = bins.content[0].length;
	    nYbins = bins.content.length;	    
	} else {
	    nXbins = bins.content.length;
	}
	    

    
	drawAxis(json.hist);
	
	if(isTH2(json.hist.type)) {
	    drawTH2bins(json.hist);
	} else {
	    drawTH1bins(json.hist);
	}
	
	drawStats(json.hist);

	svg.attr("transform", "translate(" + plotArea.margin.left + "," + (plotArea.margin.top) + ")");

    var svgBox =  document.getElementsByTagName("svg")[0].getBBox();
    d3.select("content")
	 .style("width", svgBox.width+"px")
     .style("height", svgBox.height+"px")


//     alert(new Date() - start)
}

function isTH1(type) {
    return (type == "TH1" || type == "TProfile")
}
function isTH2(type) {
    return (type == "TH2" || type == "TProfile2D")
}

function redraw(w,h) {
    start = new Date();
    d3.select("#content").remove()

    main = d3.select("body").append("div")
     .attr("id","content")
     .append("svg");
    if(!w || !h)
        svgWidth = svgHeight = 500;
    else {
        svgWidth = w;
        svgHeight = h;
    }
    
    drawHist();
}
var xLabels, yLabels;
var nXbins, nYbins;
var x,y;
var svg;
var stats;
var dx = {min: 0, max: 0, minId: 0, maxId: 0}, 
    dy = {min: 0, max: 0, minId: 0, maxId: 0},
    dz = {min: 0, max: 0, minId: 0, maxId: 0};
var axisCustomised = {x: false, y: false, z: false};
var eps = 0.00001;

function drawTitleArea(hist) {
    var titleHeight = 0;
    if(hist.title) {
        var title = main.append("g")
            .attr("transform","translate(" + 0 + "," + 0 + ")")
            .attr("id","title")
         .append("text")
            .attr("class","title")
            .attr("dominant-baseline","hanging")
            .attr("text-anchor","begin")            
            .text(hist.title);
        for(var size=2; size>=0; size-=0.1) {
            var titleBox = document.getElementById("title").getBBox();
            if(titleBox.width < (svgWidth-100) && titleBox.height < plotArea.margin.top) {
                plotArea.margin.bottom += plotArea.margin.top - (titleBox.height + 5);
                plotArea.margin.top = titleBox.height + 5;
                break;
            }
            title.style("font-size", size+"em");            
        }
        titleHeight = document.getElementById("title").getBBox().height
        titleWidth = document.getElementById("title").getBBox().width
    } else {
        plotArea.margin.bottom += plotArea.margin.top - 10;
        plotArea.margin.top = 10;
    }
    var statsBoxWidth = 100;
    var statsLabel = 
            main.append("g")
             .attr("id", "stats")
             .attr("transform","translate(" + (svgWidth - statsBoxWidth) + "," + 0 + ")")
             .on("click",function() {
                 if(d3.select("#statsBox").attr("display") == "none")
                     d3.select("#statsBox").attr("display","block");
                 else
                     d3.select("#statsBox").attr("display","none");
             }) //
    statsLabel.append("rect")
        .attr("width",statsBoxWidth)
        .attr("height",titleHeight)
        .attr("fill","white")
        .attr("class","link")
//      .attr("stroke","black")
//      .attr("stroke-width", 2);
        
    statsLabel.append("text")
        .text("Stats")
        .attr("class","link")
        .attr("dominant-baseline","middle")
        .attr("text-anchor","middle")
        .attr("transform","translate("+statsBoxWidth/2+","+titleHeight/2+")");
}

function drawAxis(hist) {
    //quick fix... remove after changing width -> widthX for TH1 
    if(bins.width)
        bins.widthX =bins.width;
    
    // checking values od dqmInfo limits;
    if(content.dqmInfo.xAxis.min != null || content.dqmInfo.xAxis.max != null) {
        if(content.dqmInfo.xAxis.min < json.hist.xaxis.first.value)
            content.dqmInfo.xAxis.min = null;
        if(content.dqmInfo.xAxis.min > json.hist.xaxis.last.value)
            content.dqmInfo.xAxis.min = null;
        if(content.dqmInfo.xAxis.max > json.hist.xaxis.last.value)
            content.dqmInfo.xAxis.max = null;
        if(content.dqmInfo.xAxis.max < json.hist.xaxis.first.value)
            content.dqmInfo.xAxis.max = null;
        if(content.dqmInfo.xAxis.min > content.dqmInfo.xAxis.max) {
            content.dqmInfo.xAxis.min = null;
            content.dqmInfo.xAxis.max = null;
        }
    }
    if(content.dqmInfo.yAxis.min != null || content.dqmInfo.yAxis.max != null) {
        if(content.dqmInfo.yAxis.min > content.dqmInfo.yAxis.max) {
            content.dqmInfo.yAxis.min = null;
            content.dqmInfo.yAxis.max = null;
        }
    }
  /*  if(json.hist.yaxis)
      if(json.hist.yaxis.scale)
           if(json.hist.yaxis.scale == "log") {
               y = d3.scale.log()
               .domain([json.hist.values.min+0.000001 //to avoid log(0)... in other case dont change anything 
                        ,json.hist.values.max ])
               .range([height, 0]);
           } else if (json.hist.yaxis.scale == "lin") {*/
    x = d3.scale.linear()
    .domain([ json.hist.xaxis.first.value, 
            json.hist.xaxis.last.value])
      .range([0, plotArea.width]);
    
    dx.min = json.hist.xaxis.first.value; 
    dx.max = json.hist.xaxis.last.value;
    dx.minId = 0;
    if(isTH1(json.hist.type))
        dx.maxId = bins.content.length;
    if(isTH2(json.hist.type))
        dx.maxId = bins.content[0].length;
    if(content.dqmInfo.xAxis.min != null || content.dqmInfo.xAxis.max != null) {
        axisCustomised.x = true;
        if(!bins.widthX) {
//            dy.min = Math.floor(content.dqmInfo.yAxis.min - y.domain()[0]/ defWidthY) * defWidthY + y.domain()[0];
            defWidthX = (hist.xaxis.last.value - hist.xaxis.first.value)/nXbins;        
            if(content.dqmInfo.xAxis.min != null && content.dqmInfo.xAxis.min >  json.hist.xaxis.first.value) {
                dx.minId = Math.floor((content.dqmInfo.xAxis.min - json.hist.xaxis.first.value) / defWidthX);
                dx.min = dx.minId * defWidthX + json.hist.xaxis.first.value;
            }
            if(content.dqmInfo.xAxis.max != null && content.dqmInfo.xAxis.max <  json.hist.xaxis.last.value) {
                dx.maxId = Math.ceil((content.dqmInfo.xAxis.max + eps - json.hist.xaxis.first.value) / defWidthX)
                dx.max = dx.maxId * defWidthX + json.hist.xaxis.first.value;
            }
        } else {
            var sumX = json.hist.xaxis.first.value;
            var i=-1;
            if(content.dqmInfo.xAxis.min != null && content.dqmInfo.xAxis.min >  json.hist.xaxis.first.value) {
                if(content.dqmInfo.xAxis.min != null && content.dqmInfo.xAxis.min >  json.hist.xaxis.first.value) {
                    while(sumX <= content.dqmInfo.xAxis.min) //find first bigger then min 
                        sumX += bins.widthX[++i];
                    dx.min = sumX - bins.widthX[i]; //save previous one
                    dx.minId = i;
                }
            }
            if(content.dqmInfo.xAxis.max != null && content.dqmInfo.xAxis.max <  json.hist.xaxis.last.value) {
                while(sumX < content.dqmInfo.xAxis.max + eps) //continue searching until find first bigger then max  
                    sumX += bins.widthX[++i];
                dx.max = sumX;
                dx.maxId = i+1;
            }
        }
         x.domain([dx.min,dx.max]);
    }

    var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");
    if(isTH2(hist.type) && dx.maxId - dx.minId < 10) 
        xAxis.ticks(dx.maxId - dx.minId +1)
    if(hist.xaxis.labels) {
        xAxis.ticks(dx.maxId - dx.minId);
    } else {
        xAxis.tickFormat(d3.format("s"));
    }
    
    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + (plotArea.height +1)+ ")")
        .attr("id","xaxis")
        .append("g")
        .attr("id","xaxisscale")
        .call(xAxis);
    if(hist.xaxis.labels) {
        var gLabels = d3.select("#xaxisscale")
        var oldLabel = d3.select("#xaxisscale").select("text");
        d3.select("#xaxisscale")
             .selectAll("text").remove();
        var xAxisBox = document.getElementById("xaxis").getBBox();
        var labelsPosition =  (xAxisBox.y+ xAxisBox.height);
        xLabels = gLabels.selectAll(".label")
        .data(hist.xaxis.labels)
        .enter().append("text")
            .text(function(d) {return d.value;})
            .attr("class","label")
            .attr("text-anchor","middle")//begin
            .attr("dominant-baseline","hanging")//middle
            .attr("x", function(d){return x(d.center);})
            .attr("y", labelsPosition+5)            
        
        for(var i = 1; i != gLabels.selectAll(".label")[0].length; ++i) {
            var firstLabel = gLabels.selectAll(".label")[0][i-1].getBBox();
            var secondLabel = gLabels.selectAll(".label")[0][i].getBBox();
            if(Math.abs(firstLabel.x + firstLabel.width) > Math.abs(secondLabel.x)) {
                 gLabels.selectAll(".label").each(function() {
                     d3.select(this)
                      .attr("text-anchor","begin")
                      .attr("dominant-baseline","middle")                      
                      .attr("transform","translate("+0+","+0+") " +
                             		"rotate("+90+" "+d3.select(this).attr("x")+",3"+")")
                      .attr("y", 3);
                 })
                 var xAxisBox = document.getElementById("xaxis").getBBox();
                 if(xAxisBox.height > plotArea.margin.bottom) {
                     var yDelta = (xAxisBox.height - plotArea.margin.bottom) + 10;
                     plotArea.height -= yDelta;
                     plotArea.margin.bottom += yDelta;
                     d3.select("#xaxis")
                     .attr("transform", "translate(0," + (plotArea.height +1)+ ")")
                 }
                break;
            }
        }
    }
        
    if(hist.xaxis.title) {
        var xAxisBox = document.getElementById("xaxis").getBBox();
        var xtitle = d3.select("#xaxis").append("text")
            .text(hist.xaxis.title)
            .attr("transform","translate("+(plotArea.width /*+ plotArea.margin.right*/)+", "+(xAxisBox.y+ xAxisBox.height)+")")
            .attr("text-anchor","end")
            .attr("dominant-baseline","hanging")            
            .attr("id","xtitle")            
            .attr("class","axistitle")
            .attr("x",0)
            .attr("y",0);
/*      for(var size=1.5; size>=0; size-=0.1) {
            ;
            if(document.getElementById("xtitle").getBBox().width < plotArea.width 
                    && document.getElementById("xaxis").getBBox().height < plotArea.margin.bottom)
                break;
            xtitle.style("font-size", size+"em");           
        }*/
    }
    
    if(isTH2(hist.type)) {
        y= d3.scale.linear()
             .domain([hist.yaxis.first.value
                      ,hist.yaxis.last.value])
             .range([plotArea.height, 0]);
    } 
    if(isTH1(hist.type)) {
        y= d3.scale.linear()
         .domain([hist.values.min
                  ,hist.values.max])
         .range([plotArea.height, 0]);
        if(content.dqmInfo.yAxis.min != null || content.dqmInfo.yAxis.max != null) {
            if(content.dqmInfo.yAxis.min == null && content.dqmInfo.yAxis.max != null) {
                content.dqmInfo.yAxis.min = hist.values.min;
            }
            if(content.dqmInfo.yAxis.max == null && content.dqmInfo.yAxis.min != null) {
                content.dqmInfo.yAxis.max = hist.values.max;
            }
        }
    }
    dy.min = y.domain()[0];
    dy.max = y.domain()[1];


    
//    content.dqmInfo.yAxis.max = 0
    if(content.dqmInfo.yAxis.min != null|| content.dqmInfo.yAxis.max != null) {
        axisCustomised.y = true;
        if(!bins.widthY) {
            if(isTH2(hist.type)) {
                defWidthY = (hist.yaxis.last.value - hist.yaxis.first.value)/nYbins;
                if(content.dqmInfo.yAxis.min != null && content.dqmInfo.yAxis.min >  y.domain()[0]) {
                    dy.minId = Math.floor((content.dqmInfo.yAxis.min - y.domain()[0])/ defWidthY) 
                    dy.min = dy.minId * defWidthY + y.domain()[0];
                }
                if(content.dqmInfo.yAxis.max != null && content.dqmInfo.yAxis.max <  y.domain()[1]) {
                    dy.maxId = Math.ceil((content.dqmInfo.yAxis.max+ eps - y.domain()[0]) / defWidthY);
                    dy.max = dy.maxId * defWidthY + y.domain()[0];
                }
            }
            if(isTH1(hist.type)) {
                dy.min = content.dqmInfo.yAxis.min;
                dy.max = content.dqmInfo.yAxis.max;
            }
        } else {
            var sumY = json.hist.yaxis.first.value;
            var i=-1;
            if(content.dqmInfo.yAxis.min != null && content.dqmInfo.yAxis.min >  y.domain()[0]) {
                while(sumY < content.dqmInfo.yAxis.min) //find first bigger then min 
                    sumY += bins.widthY[++i];
                dy.min = sumY - bins.widthY[i]; //save previous one
                dy.minId = i;
//                dy.min = content.dqmInfo.yAxis.min;
            }
            if(content.dqmInfo.yAxis.max != null && content.dqmInfo.yAxis.max <  y.domain()[1]) {
                while(sumY < content.dqmInfo.yAxis.max + eps) //continue searching until find first bigger then max  
                    sumY += bins.widthY[++i];
                dy.max = sumY;
                dy.maxId = i+1;
                //                dy.max = content.dqmInfo.yAxis.max;
            }
        }
        y.domain([dy.min,dy.max]);
    }
    if(isTH1(hist.type) && axisCustomised.x && !axisCustomised.y) {
        var yDelta = (dy.max - dy.min) * 0.02;
        dy.min = d3.min(bins.content.slice(dx.minId, dx.maxId)) - yDelta;
        dy.max = d3.max(bins.content.slice(dx.minId, dx.maxId)) + yDelta;
        y.domain([dy.min,dy.max]);
    }
    var yAxis = d3.svg.axis()
        .scale(y)
        .orient("left");
    if(isTH2(hist.type)  && dy.maxId - dy.minId < 10)
        yAxis.ticks(dy.maxId - dy.minId + 1)
    if((isTH2(hist.type)) && hist.yaxis.labels) {
        yAxis.ticks(dy.maxId - dy.minId); 
    } else {
        yAxis.tickFormat(d3.format("s"));
    }
       
    svg.append("g")
        .attr("class", "y axis")
        .attr("id","yaxis")
        .attr("transform", "translate(-1,0)")
        .append("g")
        .attr("id","yaxisscale")
        .call(yAxis);
        
    if(isTH2(hist.type) &&  hist.yaxis.labels) {
        var gLabels = d3.select("#yaxisscale")
        d3.select("#yaxisscale")
             .selectAll("text").remove();
        var labelsPosition =  (document.getElementById("yaxisscale").getBBox().x);
        yLabels = gLabels.selectAll(".label")
        .data(hist.yaxis.labels)
        .enter().append("text")
            .text(function(d) {if(d.center < dy.max && d.center > dy.min) return d.value;})
            .attr("class","label")
            .attr("text-anchor","end")
            .attr("dominant-baseline","middle")         
            .attr("transform",function(d) {return "translate("+(labelsPosition-5)+","+y(d.center)+")"+" rotate(0)"});
    }    
    
    if(hist.yaxis && hist.yaxis.title) {
        var ytitle = d3.select("#yaxis").append("g").attr("id","gytitle").append("text")
            .text(hist.yaxis.title)
            .attr("transform","translate("+
                    (document.getElementById("yaxis").getBBox().x-5)+", 0)  rotate(-90)")
            .attr("text-anchor","end")
            .attr("dominant-baseline","auto")//hanging
            .attr("class","axistitle")
            .attr("id","ytitle")
            .attr("x",-10)
            .attr("y",0);
    }
    var yTitleSize = 1.5;
    var yLabelSize = 10;
    
    var titleBox = document.getElementById("title").getBBox();
    //try only 5 times to corect it if not possible leave it
    for (var i = 0; i<5 &&(document.getElementById("yaxis").getBBox().height > plotArea.height
            || document.getElementById("yaxis").getBBox().width > plotArea.margin.left); ++i) {
        if(hist.yaxis && hist.yaxis.title && document.getElementById("ytitle").getBBox().width > plotArea.height) {
            yTitleSize =yTitleSize*plotArea.height/document.getElementById("ytitle").getBBox().width - 0.05;
            ytitle.style("font-size", yTitleSize+"em");
        }
        if(document.getElementById("yaxis").getBBox().width > plotArea.margin.left) {
            yLabelSize =Math.round(yLabelSize*(plotArea.margin.left/document.getElementById("yaxis").getBBox().width - 0.05));
//          yLabels.style("font-size", yLabelSize+"px");
            d3.select("#yaxisscale").selectAll("text").style("font-size", yLabelSize+"px");
            if(ytitle) {
                yTitleSize -= 0.2; 
                ytitle.attr("transform","translate("+(document.getElementById("yaxisscale").getBBox().x)+", "+0+")  rotate(-90)")
                .style("font-size", yTitleSize+"em");
            }
        }
    }
    plotArea.margin.left = document.getElementById("yaxis").getBBox().width;
    
    var xTitleSize = 1.5;
    var xLabelSize = 10;
    var xTickSize = 6;
    var i;
    for (i = 0; i<5 &&(document.getElementById("xaxis").getBBox().width > plotArea.width
            || document.getElementById("xaxis").getBBox().height > plotArea.margin.bottom); ++i) {
        if(hist.xaxis.title && document.getElementById("xtitle").getBBox().width > plotArea.width) {
            xTitleSize =xTitleSize*plotArea.width/document.getElementById("xtitle").getBBox().width - 0.05;
            xtitle.style("font-size", xTitleSize+"em");
        }
        if(document.getElementById("xaxis").getBBox().height > plotArea.margin.bottom) {
            xLabelSize -= 1;
            xTickSize -= 0.5;
            d3.select("#xaxis").selectAll(".tick")
              .attr("y2",xTickSize);
            if(hist.xaxis.labels) {
                var labelsPosition =  (xAxisBox.y);
                xLabels
                 .style("font-size", xLabelSize+"px")
            } else
                d3.select("#xaxisscale").selectAll("text")
                 .style("font-size", xLabelSize+"px")
                 .attr("y",xTickSize+3);
            var xLabelBox = document.getElementById("xaxisscale").getBBox();
            if(xtitle) {
                xTitleSize -= 0.2; 
                xtitle
                 .attr("transform","translate("+(plotArea.width/*+ plotArea.margin.right*/)+", "+(xLabelBox.y+xLabelBox.height)+")")
                 .style("font-size", xTitleSize+"em");
            }
        }
    }
}
var lineString;
function drawTH1bins(hist) {
    var defWidth;
    if(!bins.width) {
     defWidth = (hist.xaxis.last.value - hist.xaxis.first.value)/bins.content.length;
    }
    stepBins = [{x:dx.min, y:dy.min}];
    var sumX = dx.min;
    var width = bins.width;
    contentArray = bins.content;
    
/*    widthY = widthY.slice(dy.minId, dy.maxId);
    nYbins = contentArray.length    
*/
    contentArray = contentArray.slice(dx.minId, dx.maxId);
    if(bins.width) {

        width = width.slice(dx.minId, dx.maxId);
    }
//    var sumX = hist.xaxis.first.value;
    lineString = "M";
    var stepLabels = [];
    for(var i = 0; i!=contentArray.length; ++i) {
        var value = contentArray[i];
        lineString += x(sumX) + ",";
        if(contentArray[i] < dy.min) {
            value = dy.min;
            lineString += y(dy.min) + "M";
        } else
            if(contentArray[i] > dy.max) {
                value = dy.max;
                lineString += y(dy.max) + "M";
            } else 
                lineString += y(value) + "L";
        stepBins.push({
            x: sumX,
            y: value
        })
        if(bins.width) {
            sumX +=  width[i];
            if(hist.xaxis.labels)
                stepLabels.push(sumX);
        } else {
            sumX += defWidth;
        }
        /*if(bins.widthX != null && sumX > dx.max) {
            stepBins.pop();
            break;
        }*/
 /*       if(sumX <= dx.min) {
            stepBins.pop();
            continue;
        }*/
            
        stepBins.push({
            x: sumX,
            y: value
        })
        lineString += x(sumX) +","+y(value) + "L"; 
/*        if(sumX > dx.max) {
            break;
        }*/
    }
    lineString = lineString.substring(0,lineString.length -1 )
    stepBins.push({x:sumX, y:dy.min});
    

    
    var binsTable;
    var line = d3.svg.line()
        .x(function(d,i) { return x(d.x); })
        .y(function(d) { return y(d.y+0.000001); });
    var area = d3.svg.area()
        .x(line.x())
        .y1(line.y())
        .y0(y(dy.min));
    var cells = svg 
        .append("g")
         .style("width", plotArea.width)
         .style("heigth", plotArea.heigth)
         
//    cells.datum(stepBins);
         cells.append("path")
         .attr("class", "line")
         .attr("d", lineString);
/*    cells.append("path")
        .attr("class", "area")
        .attr("d", area);

    cells.append("path")
        .attr("class", "line")
        .attr("d", line);*/
}
var stepsX, stepsY, contentArray,widthX, widthY ; 
var minVal, maxVal, z, maxOfCols , minOfCols;
function drawTH2bins(hist) {

    contentArray = bins.content;
    widthX = hist.bins.widthX;
    widthY = hist.bins.widthY;
    stepsX=[dx.min]; stepsY=[dy.min];   
     var   defWidthX, defWidthY,
        sumX = hist.xaxis.first.value, sumY = hist.yaxis.first.value,
        defRectWidth, defRectHeight,
        yDefWidth,xDefWidth;
//     alert("x"+dx.minId+", "+dx.maxId)
//     alert("y"+dy.minId+", "+dy.maxId)
     
    if(bins.widthY) {
        sumY = dy.min;
        contentArray = contentArray.slice(dy.minId, dy.maxId);
        widthY = widthY.slice(dy.minId, dy.maxId);
        nYbins = contentArray.length
//        var yMinId = 0, yMaxId = nYbins;
        for(var i = 0; i!=nYbins; ++i) {
            sumY +=  widthY[i];
/*            if(axisCustomised.y && sumY < dy.min) {
                yMinId = i;
                continue;
            }*/
            stepsY.push(sumY)
/*            if(axisCustomised.y && sumY > dy.max) {
                yMaxId = i;
                break;
            }*/
        }
//        alert(yMinId  + "  " + yMaxId)
//        contentArray = contentArray.slice(yMinId, yMaxId);
//        widthY = widthY.slice(dx.minId, dx.maxId)

    } else {
        defWidthY = (hist.yaxis.last.value - hist.yaxis.first.value)/nYbins;
        defRectHeight = y(hist.yaxis.first.value)-y(hist.yaxis.first.value+defWidthY);
        if(axisCustomised.y) {
            var yMinId = (dy.min - hist.yaxis.first.value)/defWidthY;
            var yMaxId = (dy.max - hist.yaxis.first.value)/defWidthY;
            contentArray = contentArray.slice(yMinId, yMaxId);
            
            nYbins = contentArray.length;     
            yDefWidth = 
                d3.scale.linear()
                 .domain([0,(dy.max - dy.min)/defWidthY])
                 .range([plotArea.height-defRectHeight, -defRectHeight]);            
        } else {
            yDefWidth = d3.scale.linear()
             .domain([0,(hist.yaxis.last.value- hist.yaxis.first.value)/defWidthY])
             .range([plotArea.height-defRectHeight, -defRectHeight]); 
        }
    }

    if(bins.widthX) {
        var xMinId = 0, xMaxId = nXbins;
        for(var i = 0; i!=nYbins; ++i) {
//            contentArray[i] = contentArray[i].slice(xMinId, xMaxId);
            contentArray[i] = contentArray[i].slice(dx.minId, dx.maxId);
        }
        widthX = widthX.slice(dx.minId, dx.maxId)
        nXbins = contentArray[0].length
        sumX = dx.min;
        for(var i = 0; i!=nXbins; ++i) {
            sumX += widthX[i];
/*            if(axisCustomised.x && sumX < dx.min) {
                xMinId = i;
                continue;
            }*/            
            stepsX.push(sumX);
/*            if(axisCustomised.x && sumX > dx.max) {
                xMaxId = i+1;
                break;
            }*/
        }
    } else {
         defWidthX = (hist.xaxis.last.value - hist.xaxis.first.value)/nXbins;
         defRectWidth = x(hist.xaxis.first.value+defWidthX) - x(hist.xaxis.first.value)
         if(axisCustomised.x) {
             var xMinId = (dx.min - hist.xaxis.first.value)/defWidthX;
             var xMaxId = (dx.max - hist.xaxis.first.value)/defWidthX;
             for(var i = 0; i!=nYbins; ++i) {
                 contentArray[i] = contentArray[i].slice(xMinId, xMaxId);
             }
             nXbins = contentArray[0].length;
             xDefWidth =
                 d3.scale.linear()
                 .domain([0,(dx.max- dx.min)/defWidthX])
                 .range([0, plotArea.width]);             
         } else {
             xDefWidth = 
                 d3.scale.linear() 
                 .domain([0,(hist.xaxis.last.value- hist.xaxis.first.value)/defWidthX]) 
                 .range([0, plotArea.width]);
         }
     }
    
    
    minVal =  hist.values.min
    maxVal =  hist.values.max;
    if(axisCustomised.x || axisCustomised.y) {
        maxOfCols = []; minOfCols = [];
        for(var col = 0; col != contentArray.length; ++col) {
            
            maxOfCols.push(d3.max(contentArray[col]));
            minOfCols.push(d3.min(contentArray[col]));
        }
        minVal = d3.min(minOfCols);
        maxVal = d3.max(maxOfCols);
    }
    if(content.dqmInfo.zAxis.max != null || content.dqmInfo.zAxis.min != null ) {

        if(content.dqmInfo.zAxis.max != null && content.dqmInfo.zAxis.min != null ) {
            if(content.dqmInfo.zAxis.max > content.dqmInfo.zAxis.min) {
                minVal = content.dqmInfo.zAxis.min;
                maxVal = content.dqmInfo.zAxis.max;
            }
        } else {
            if(content.dqmInfo.zAxis.max != null) {
                if(content.dqmInfo.zAxis.max > minVal) {
                    maxVal = content.dqmInfo.zAxis.max;
                }
            }
            if(content.dqmInfo.zAxis.min != null) {
                if(content.dqmInfo.zAxis.min < maxVal) {
                    minVal = content.dqmInfo.zAxis.min;
                }
            }
        }
    }
        
    var range = (maxVal-minVal);
    z = d3.scale.linear()
       .domain([minVal, minVal+range/5, minVal+2*range/5, minVal+3*range/5, minVal+4*range/5,  maxVal])
       .range(["rgb(255,0,255)","rgb(0,0,255)","rgb(0,255,255)", "rgb(0,255,0)","rgb(255,255,0)", "rgb(255,0,0)"])
       .interpolate(d3.interpolateRgb);    
    
    var rects = svg
      .append("g")
       .attr("id","cells")
       .attr("width", plotArea.width)
       .attr("heigth", plotArea.heigth)
       .selectAll(".row")
       .data(contentArray)
       .enter()
      .append("g")
       .attr("id","row")
       .selectAll(".point")
       .data(function(d){return d;})
       .enter()
      .append("rect")
       .attr("id",function(d,i,j) {return "point"+i+j;})
       .style("fill",function(d,i,j) {if(d==0 || d<minVal) {return "rgb(255,255,255)";} else {if(d>maxVal) {return z(maxVal)} else {return z(d);}}});
    if(bins.widthX)
        rects
         .attr("x",function(d,i,j) {return x(stepsX[i]);})
         .attr("width",function(d,i,j) {return x(widthX[i]+ dx.min);})
    else 
        rects
         .attr("x",function(d,i,j) {return xDefWidth(i);})
         .attr("width",defRectWidth)
        
        
    if(bins.widthY)
        rects
         .attr("y",function(d,i,j) {return y(stepsY[j]+ widthY[j]);})
         .attr("height",function(d,i,j) {return y(dy.max- widthY[j]);})     
    else
        rects
         .attr("y",function(d,i,j) {return yDefWidth(j);})
         .attr("height",defRectHeight)

    var cells = document.getElementById("cells").getBBox();
    
    var values = d3.range(maxVal, minVal, (minVal-maxVal)/200);
    var xx = d3.scale.ordinal()
       .domain(values)
       .rangeBands([0,cells.height],0);
    
    svg.append("g")
     .attr("id","zaxis")
     .selectAll("rect")
       .data(values)
     .enter().append("rect")
        .attr("x", cells.x + cells.width + 1)
        .attr("y", xx)
        .attr("height", xx.rangeBand())
        .attr("width", plotArea.margin.right * 0.3)
        .style("fill", z)
       
    var zz = d3.scale.linear()
       .domain([maxVal, minVal])
       .range([0,cells.height]);
    
    var zAxis = d3.svg.axis()
        .scale(zz)
        .tickSize(10)
        .orient("right")
        .tickFormat(d3.format("s"));
    var zAxisBox = document.getElementById("zaxis").getBBox();
    
    d3.select("#zaxis").append("g")
        .attr("class", "z axis")
        .attr("transform", "translate("+(zAxisBox.x+zAxisBox.width)+",0)")
        .attr("id","zaxis")
        .call(zAxis);
    
    var zTitleSize = 1.5;
    var zLabelSize = 10;
    var zTicksLane = 10;
    var i;
    for (i = 0; i<5 && document.getElementById("zaxis").getBBox().width > plotArea.margin.right; ++i) {
            zLabelSize--;
            d3.select("#zaxis").selectAll("text")
              .style("font-size", zLabelSize+"px")
              .attr("x",zLabelSize+3);
            d3.select("#zaxis").selectAll(".tick")
              .attr("x2",zLabelSize)
    }
}

function drawStats(hist) {
    var titleBox = document.getElementById("title").getBBox();  
    var statsBoxWidth = 150, statsBoxHeight = 220; 
    var statsBox = 
        main.append("g")
         .attr("id","statsBox")
         .attr("transform","translate(" + (svgWidth - statsBoxWidth) + "," + plotArea.margin.top + ")")
         .attr("display","none");

    var statsRect = statsBox.append("rect")
        .attr("width",statsBoxWidth)
        .attr("height",10)
        .attr("fill","white")
        .attr("stroke","black")
        .attr("stroke-width", 2);
    
    statsBox.append("text")
        .text("X ")
        .attr("dominant-baseline","hanging")
        .attr("text-anchor","end")
        .attr("font-weight", "bold")
        .attr("font-size",15)
        .attr("transform","translate("+(statsBoxWidth-2)+","+2+")")
        .attr("class","link")
        .on("click",function() {d3.select("#statsBox").attr("display","none")});
    statsBox.selectAll("tspan")

    var statsNames = statsBox.append("text")
        .attr("id", "statsNames")
        .attr("font-weight", "bold")
        .attr("transform","translate("+(2)+","+18+")");
    var statsVals = statsBox.append("text")
        .attr("id", "statsVals")
        .attr("transform","translate("+(2)+","+18+")")
    for(var k in hist.stats) {
        statsNames
        .append("tspan")
         .attr("dy",15).attr("x",0)
         .text(k);        
        if( typeof hist.stats[k] != "object") {
           statsVals
            .append("tspan")
//            .attr("transform","translate("+(statsBoxWidth-2)+","+20+")")
            .attr("text-anchor","end")
            .attr("dy",15).attr("x",statsBoxWidth-5)
            .text(hist.stats[k]);
        } else {
            var wasObj = true;
            for(var axis in hist.stats[k]) {
                if(!wasObj) {
                    statsNames
                    .append("tspan")
                     .attr("dy",15).attr("x",0)
                     .text(" ");
                }
                wasObj = false;
                statsNames
                .append("tspan")
                 .attr("x",32)
                 .text(axis);
                var wasSubObj = true;                
                for(var vals in hist.stats[k][axis]) {
                    if(!wasSubObj) {
                        statsNames
                        .append("tspan")
                         .attr("dy",15).attr("x",0)
                         .text(" ");
                    }
                    wasSubObj = false;
                    statsNames
                    .append("tspan")
                     .attr("x",45)
                     .text(vals);
                    
                    statsVals
                    .append("tspan")
        //            .attr("transform","translate("+(statsBoxWidth-2)+","+20+")")
                    .attr("text-anchor","end")
                    .attr("dy",15).attr("x",statsBoxWidth-5)
                    .text(hist.stats[k][axis][vals]);
                }
            }
        }
    }
    if(isTH1(hist.type)) {
        statsNames
        .append("tspan")
         .attr("dy",15).attr("x",0)
         .text("integral");
        
        statsVals
        .append("tspan")
//        .attr("transform","translate("+(statsBoxWidth-2)+","+20+")")
        .attr("text-anchor","end")
        .attr("dy",15).attr("x",statsBoxWidth-5)
        .text(bins.integral);
    }
    statsBox.attr("display","block")
    var statsNamesBox = document.getElementById("statsNames").getBBox();
    var statsBoxHeight= statsNamesBox.y + statsNamesBox.height+18;
    if(isTH2(hist.type)) {
        statsNames
        .append("tspan")
         .attr("dy",15).attr("x",0)
         .text("integral");
        statsNamesBox = document.getElementById("statsNames").getBBox();
        statsBoxHeight= statsNamesBox.y + statsNamesBox.height+18;
        var pos = 0;

        var integral = 
                statsBox
                 .append("g")
                 .attr("id","integral");
        var integralRow1 =
                integral
                 .append("text")
                 .attr("text-anchor","end")
                 .attr("transform","translate("+(statsBoxWidth-5)+","+statsBoxHeight+")");
        
        var integralRow2 =             
                integral
                 .append("text")
                 .attr("text-anchor","end")
                 .attr("transform","translate("+(statsBoxWidth-5)+","+(statsBoxHeight+15)+")");
        
        var integralRow3 = 
                integral
                 .append("text")
                 .attr("text-anchor","end")
                 .attr("transform","translate("+(statsBoxWidth-5)+","+(statsBoxHeight+30)+")");
        var pos = 0;
        for(var i = 2 ; i!= -1 ; --i) {
            integralRow1 
            .append("tspan")
            .attr("x", pos)
            .text(bins.integral[0][i]);
            
            integralRow2 
             .append("tspan")
            .attr("x", pos)
             .text(bins.integral[1][i]);
             
            integralRow3 
            .append("tspan")
            .attr("x", pos)
            .text(bins.integral[2][i]);
            
            pos = -(document.getElementById("integral").getBBox().width+10);
        }
    }
    
    statsNamesBox = document.getElementById("statsBox").getBBox();
    statsBoxHeight= statsNamesBox.y+statsNamesBox.height;

   
    var xDelta = 0; 
    var statsValsBox = document.getElementById("statsVals").getBBox();
    statsBox.attr("display","none")    
    if(statsNamesBox.x > statsValsBox.x) {
        xDelta = statsValsBox.x - 30;
    } else {
        if(statsNamesBox.x + 30 > statsValsBox.x) {
            xDelta = (statsNamesBox.x - 30);
        }
    }
    if (xDelta != 0) {
        statsRect.attr("x", xDelta )
                 .attr("width", statsBoxWidth + Math.abs(xDelta));
        statsNames.attr("transform", "translate("+(xDelta + 2)+ ",18)");
    }
    statsRect.attr("height", statsBoxHeight+2);
}

 if(parent && parent.GUI) {
	 var extWin = parent.GUI.Plugin.DQMCanvas.getJsonWin();
	 svgWidth = extWin.getInnerWidth()-20/**0.95*/; svgHeight  =  extWin.getInnerHeight()-20/**0.95*/;
 } else {
	 svgWidth = svgHeight = 500;
 }
 main= d3.select("body")
     .append("div")
     .attr("id","content")
     .append("svg")

 if(json.hist.type == "TH2" 
     || json.hist.type == "TProfile2D" 
     || json.hist.type == "TH1" 
     || json.hist.type == "TProfile")
 {
		drawHist();
 }
  			
</script>
</body>
</html>

