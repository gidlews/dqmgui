<!DOCTYPE html>
<meta charset="utf-8">
<html>
<style>
body {
  font: 10px sans-serif;
}

.axis path, .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.area {
  fill: lightsteelblue;
}

.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.dot {
  fill: white;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.axistitle {
	font-size: 1.5em;
	font-weight:bold;
}

.title {
	font-size: 2em;
	font-weight:bold;
}
.link:hover {
    cursor:pointer
}
</style>
<body style="width:100px">
<!--  <script src="d3\d3.v2.js"></script> -->
<!--  <script src="https://raw.github.com/mbostock/d3/master/d3.v2.js"></script> -->
<script src="http://d3js.org/d3.v2.js"></script>


<script>
var xLabels, yLabels;
//window.frames[1].document.getElementById('yaxis')
//height
//313.1015625
//
//width
//527.12109375
function drawTH2() {
	
	var titleHeight = 0;
	var titleWidth = 0;
	if(json.hist.title) {
		var title = main.append("g")
	 		.attr("transform","translate(" + 0 + "," + 0 + ")")
	 		.attr("id","title")
		 .append("text")
		 	.attr("class","title")
		 	.attr("dominant-baseline","hanging")
			.attr("text-anchor","begin")		 	
		 	.text(json.hist.title);
		for(var size=2; size>=0; size-=0.1) {
			var titleBox = document.getElementById("title").getBBox();
			if(titleBox.width < width && titleBox.height < plotAreaMargin.top) {
				plotAreaMargin.bottom += plotAreaMargin.top - (titleBox.height + 5);
				plotAreaMargin.top = titleBox.height + 5;
				break;
			}
			title.style("font-size", size+"em");			
		}
		titleHeight = document.getElementById("title").getBBox().height
		titleWidth = document.getElementById("title").getBBox().width
	} else {
		plotAreaMargin.bottom += plotAreaMargin.top - 10;
		plotAreaMargin.top = 10;
	}
	var statsBoxWidth = 100;
	var statsLabel = 
			main.append("g")
			 .attr("id", "stats")
			 .attr("transform","translate(" + (width) + "," + 0 + ")")
			 .on("click",function() {d3.select("#statsBox").attr("display","block")}) //
	statsLabel.append("rect")
		.attr("width",statsBoxWidth)
		.attr("height",titleHeight)
		.attr("fill","white")
        .attr("class","link")
//		.attr("stroke","black")
//		.attr("stroke-width", 2);
		
	statsLabel.append("text")
		.text("Stats")
        .attr("class","link")
		.attr("dominant-baseline","middle")
		.attr("text-anchor","middle")
		.attr("transform","translate("+statsBoxWidth/2+","+titleHeight/2+")");
		
	if(document.getElementById("title").getBBox().height == 0)
		titleHeight = document.getElementById("stats").getBBox().height;
	
	var svg = main
		 	   .append("g")
		 	   .attr("transform", "translate(" + plotAreaMargin.left + "," + plotAreaMargin.top + ")");
	plotWidth = svgWidth - plotAreaMargin.left - plotAreaMargin.right;
	var x = d3.scale.linear()
	  .domain([ json.hist.xaxis.first.value, 
	          json.hist.xaxis.last.value])
	 	.range([0, plotWidth]);
	
	var deltaWidth = (json.hist.values.max - json.hist.values.min)*0.025;
	/*	if(json.hist.values.min != 0) 
		 json.hist.values.min -= deltaWidth;
	json.hist.values.max += deltaWidth;*/
	//var y;
	/*	if(json.hist.yaxis)
		if(json.hist.yaxis.scale)
			 if(json.hist.yaxis.scale == "log") {
				 y = d3.scale.log()
			     .domain([json.hist.values.min+0.000001 //to avoid log(0)... in other case dont change anything 
			              ,json.hist.values.max ])
			     .range([height, 0]);
			 } else if (json.hist.yaxis.scale == "lin") {*/
	plotHeight = svgHeight - plotAreaMargin.top - plotAreaMargin.bottom; 
	var y
	if(json.hist.type == "TH2" || json.hist.type == "TProfile2D" ) {
		y= d3.scale.linear()
			 .domain([json.hist.yaxis.first.value
			          ,json.hist.yaxis.last.value])
			 .range([plotHeight, 0]);
	} else if(json.hist.type == "TH1" || json.hist.type == "TProfile") {
		y= d3.scale.linear()
		 .domain([json.hist.values.min
		          ,json.hist.values.max])
		 .range([plotHeight, 0]);
	}
	
	
	//		 }
	
	var nXbins = bins.content[0].length,
		nYbins = bins.content.length;
	
	var xAxis = d3.svg.axis()
	.scale(x)
	.orient("bottom");
//	json.hist.yaxis.labels = [{"value":"bbbbbbb", "center": ""}]
	
	
	
	if(json.hist.xaxis.labels) {
		xAxis.ticks(nXbins);
	} else {
		xAxis.tickFormat(d3.format("s"));
	}
	var yAxis = d3.svg.axis()
	    .scale(y)
	    .orient("left");
	
	if((json.hist.type == "TH2" || json.hist.type == "TProfile2D") && json.hist.yaxis.labels) {
		yAxis.ticks(nYbins);
	} else {
		yAxis.tickFormat(d3.format("s"));
	}
	
	svg.append("g")
	    .attr("class", "x axis")
	    .attr("transform", "translate(0," + plotHeight + ")")
	    .attr("id","xaxis")
	    .append("g")
	    .attr("id","xaxisscale")	    
	    .call(xAxis);
	     
	svg.append("g")
	    .attr("class", "y axis")
	    .attr("id","yaxis")
	    .append("g")
	    .attr("id","yaxisscale")
	    .call(yAxis);	
	//nXbins
	
	if(json.hist.xaxis.labels) {
		var gLabels = d3.select("#xaxisscale")
		var oldLabel = d3.select("#xaxisscale").select("text");
		d3.select("#xaxisscale")
		 	 .selectAll("text").remove();
		var xAxisBox = document.getElementById("xaxis").getBBox();
		var labelsPosition =  (xAxisBox.y+ xAxisBox.height);
		xLabels = gLabels.selectAll(".label")
		.data(json.hist.xaxis.labels)
		.enter().append("text")
	  		.text(function(d) {return d.value;})
	  		.attr("class","label")
			.attr("text-anchor","middle")//begin
			.attr("dominant-baseline","hanging")//middle  		
			.attr("transform",function(d) {return "translate("+x(d.center)+","+(labelsPosition+5)+")"/*+" rotate(30)"*/});
	}
	 
	if((json.hist.type == "TH2" || json.hist.type == "TProfile2D") &&  json.hist.yaxis.labels) {
		var gLabels = d3.select("#yaxisscale")
		d3.select("#yaxisscale")
		 	 .selectAll("text").remove();
		var labelsPosition =  (document.getElementById("yaxisscale").getBBox().x);
		yLabels = gLabels.selectAll(".label")
		.data(json.hist.yaxis.labels)
		.enter().append("text")
	  		.text(function(d) {return d.value;})
	  		.attr("class","label")
			.attr("text-anchor","end")
			.attr("dominant-baseline","middle")  		
			.attr("transform",function(d) {return "translate("+(labelsPosition-5)+","+y(d.center)+")"+" rotate(0)"});
	}
	
		
	if(json.hist.xaxis.title) {
		var xAxisBox = document.getElementById("xaxis").getBBox();
		var xtitle = d3.select("#xaxis").append("text")
		  	.text(json.hist.xaxis.title)
			.attr("transform","translate("+(/*plotAreaMargin.left +*/plotWidth)+", "+(xAxisBox.y+ xAxisBox.height)+")")
			.attr("text-anchor","end")
			.attr("dominant-baseline","hanging")			
			.attr("id","xtitle")			
			.attr("class","axistitle")
			.attr("x",0)
			.attr("y",0);
/*		for(var size=1.5; size>=0; size-=0.1) {
			;
			if(document.getElementById("xtitle").getBBox().width < plotWidth 
					&& document.getElementById("xaxis").getBBox().height < plotAreaMargin.bottom)
				break;
			xtitle.style("font-size", size+"em");			
		}*/
	}
	
	if(json.hist.yaxis && json.hist.yaxis.title) {
	 	var ytitle = d3.select("#yaxis").append("g").attr("id","gytitle").append("text")
		  	.text(json.hist.yaxis.title)
			.attr("transform","translate("+
					(document.getElementById("yaxis").getBBox().x-5)+", 0)  rotate(-90)")
			.attr("text-anchor","end")
			.attr("dominant-baseline","auto")//hanging
			.attr("class","axistitle")
			.attr("id","ytitle")
			.attr("x",-10)
			.attr("y",0);
	}
	var yTitleSize = 1.5;
	var yLabelSize = 10;
	var titleBox = document.getElementById("title").getBBox();
	//try only 5 times to corect it if not possible leave it
	for (var i = 0; i<5 &&(document.getElementById("yaxis").getBBox().height > plotHeight
			|| document.getElementById("yaxis").getBBox().width > plotAreaMargin.left); ++i) {
		if(json.hist.yaxis && json.hist.yaxis.title && document.getElementById("ytitle").getBBox().width > plotHeight) {
			yTitleSize =yTitleSize*plotHeight/document.getElementById("ytitle").getBBox().width - 0.05;
			ytitle.style("font-size", yTitleSize+"em");
		}
		if(document.getElementById("yaxis").getBBox().width > plotAreaMargin.left) {
			yLabelSize =Math.round(yLabelSize*(plotAreaMargin.left/document.getElementById("yaxis").getBBox().width - 0.05));
//			yLabels.style("font-size", yLabelSize+"px");
			d3.select("#yaxisscale").selectAll("text").style("font-size", yLabelSize+"px");
			if(ytitle) {
				yTitleSize -= 0.2; 
				ytitle.attr("transform","translate("+(document.getElementById("yaxisscale").getBBox().x)+", "+(titleBox.y + titleBox.height)+")  rotate(90)")
				.style("font-size", yTitleSize+"em");
			}
		}
	}
	plotAreaMargin.left = document.getElementById("yaxis").getBBox().width;
	
	var xTitleSize = 1.5;
	var xLabelSize = 10;
	var xTickSize = 6;
	var i;
	for (i = 0; i<5 &&(document.getElementById("xaxis").getBBox().width > plotWidth
			|| document.getElementById("xaxis").getBBox().height > plotAreaMargin.bottom); ++i) {
		if(json.hist.xaxis.title && document.getElementById("xtitle").getBBox().width > plotWidth) {
			xTitleSize =xTitleSize*plotWidth/document.getElementById("xtitle").getBBox().width - 0.05;
			xtitle.style("font-size", xTitleSize+"em");
		}
		if(document.getElementById("xaxis").getBBox().height > plotAreaMargin.bottom) {
			xLabelSize -= 1;
			xTickSize -= 0.5;
			d3.select("#xaxis").selectAll(".tick")
			  .attr("y2",xTickSize);
//			yLabels.style("font-size", yLabelSize+"px");
			if(json.hist.xaxis.labels) {
				var labelsPosition =  (xAxisBox.y);
//				d3.select("xaxisscale").selectAll("text")
				xLabels
				 .style("font-size", xLabelSize+"px")
//				 .selectAll("text")
				 .attr("transform",function(d) {return "translate("+x(d.center)+","+(xTickSize+2)+")"/*+" rotate(30)"*/});				
			} else
				d3.select("#xaxisscale").selectAll("text")
				 .style("font-size", xLabelSize+"px")
				 .attr("y",xTickSize+3);
			var xLabelBox = document.getElementById("xaxisscale").getBBox();
			if(xtitle) {
				xTitleSize -= 0.2; 
				xtitle
				 .attr("transform","translate("+(plotAreaMargin.left+ plotWidth)+", "+(xLabelBox.y+xLabelBox.height)+")")
				 .style("font-size", xTitleSize+"em");
			}
		}
	}
	//d3.select("#xaxis").attr("transform","translate(50,0)")
	if(json.hist.type == "TH2" || json.hist.type == "TProfile2D") {
		var range = (json.hist.values.max-json.hist.values.min);
		var min = json.hist.values.min;
		var z = d3.scale.linear()
		   .domain([min, min+range/5, min+2*range/5, min+3*range/5, min+4*range/5,  json.hist.values.max])
		//   .range(["blue","green","red"])
		   .range(["rgb(255,0,255)","rgb(0,0,255)","rgb(0,255,255)", "rgb(0,255,0)","rgb(255,255,0)", "rgb(255,0,0)"])
		//   .range(["rgb(255,0,0)","rgb(255,255,0)", "rgb(0,255,0)","rgb(0,255,255)","rgb(0,0,255)"])
		   .interpolate(d3.interpolateRgb);
		/*	var z = d3.scale.linear()
			 .domain([json.hist.values.min, json.hist.values.max])
			 .range([Math.PI,0]);*/
		
		
		
		var stepsX=[json.hist.xaxis.first.value], stepsY=[json.hist.yaxis.first.value], 
			defWidthX, defWidthY,
			sumX = json.hist.xaxis.first.value, sumY = json.hist.yaxis.first.value,
			defRectWidth, defRectHeight,
			yDefWidth,xDefWidth;
		
		if(bins.widthX)
		 	for(var i = 0; i!=nXbins; ++i) { 
				sumX += bins.widthX[i];
		 		stepsX.push(sumX);
		 	}
		 else { 
			 defWidthX = (json.hist.xaxis.last.value - json.hist.xaxis.first.value)/nXbins;
			 defRectWidth = x(json.hist.xaxis.first.value+defWidthX) - x(json.hist.xaxis.first.value)
			 xDefWidth = d3.scale.linear() 
			      .domain([ 0, 
			              (json.hist.xaxis.last.value- json.hist.xaxis.first.value)/defWidthX]) 
			     	.range([0, plotWidth]);
		 }
		if(bins.widthY)	 		
		 	for(var i = 0; i!=nYbins; ++i) {
				sumY +=  bins.widthY[i];
		 		stepsY.push(sumY)
		 	}
		else {
			defWidthY = (json.hist.yaxis.last.value - json.hist.yaxis.first.value)/nYbins;
			defRectHeight = y(json.hist.yaxis.first.value)-y(json.hist.yaxis.first.value+defWidthY);
		//	 var y = d3.scale.linear()
		//	 .domain([json.hist.yaxis.first.value
		//	          ,json.hist.yaxis.last.value])
		//	 .range([height, 0]);
			yDefWidth = d3.scale.linear()
			 .domain([0
			          ,(json.hist.yaxis.last.value- json.hist.yaxis.first.value)/defWidthY])
		//	 .range([defWidthY*(height-defRectHeight+json.hist.yaxis.first.value), defWidthY*(defRectHeight+json.hist.yaxis.first.value)]);
			 .range([plotHeight-defRectHeight, -defRectHeight]);        
		}
		
		var rects = svg
		  .append("g")
		   .attr("id","cells")
		   .selectAll(".row")
		   .data(bins.content)
		   .enter()
		  .append("g")
		   .attr("id","row")
		   .selectAll(".point")
		   .data(function(d){return d;})
		   .enter()
		  .append("rect")
		//  .attr("id","point")
		   .attr("id",function(d,i,j) {return "point"+i+j;})
		   .style("fill",function(d,i,j) {if(d==0) {return "rgb(255,255,255)";} else {return z(d);}});
		//.style("fill",function(d,i,j) {if(d==0) {return "rgb(255,255,255)";} else {return getColor(z(d));}});
		if(bins.widthX)
			rects
			 .attr("x",function(d,i,j) {return x(stepsX[i]); })
			 .attr("width",function(d,i,j) {return x(bins.widthX[i]+ json.hist.xaxis.first.value);})
		else 
			rects
			 .attr("x",function(d,i,j) {return xDefWidth(i);})
			 .attr("width",defRectWidth)
			
			
		if(bins.widthY)
			rects
			 .attr("y",function(d,i,j) {return y(stepsY[j]);})
		     .attr("height",function(d,j,i) {return y(json.hist.yaxis.last.value- bins.widthY[j]);})	 
		else
			rects
			 .attr("y",function(d,i,j) {return yDefWidth(j);})
			 .attr("height",defRectHeight)		
			
			/*
			
			.attr("y",function(d,i,j) {if(bins.widthY) return y(stepsY[i]); else return yDefWidth(j);})
		//   .attr("x",function(d,j,i) {if(bins.widthX) return x(stepsX[j]); else return x(j*defWidthX + json.hist.xaxis.first.value);})
		   .attr("x",function(d,i,j) {if(bins.widthX) return x(stepsX[j]); else return xDefWidth(i);})
		//   .attr("y",function(d,j,i) {if(bins.widthY) return y(stepsY[i]); else return y(i*defWidthY + json.hist.yaxis.first.value)-defRectHeight;})
		   .attr("y",function(d,i,j) {if(bins.widthY) return y(stepsY[i]); else return yDefWidth(j);})
		//   .attr("y", yy)
		//   .attr("width",function(d,j,i) {if(bins.widthX) return x(bins.widthX[j]+ json.hist.xaxis.first.value); else return defRectWidth;})
		//   .attr("height",function(d,j,i) {if(bins.widthY) {return y(json.hist.yaxis.last.value- bins.widthY[i]);} else return defRectHeight;})
		   .attr("width",defRectWidth)
		   .attr("height",defRectHeight)*/
		   
		var cells = document.getElementById("cells").getBBox();
		var values = d3.range(json.hist.values.max, json.hist.values.min, (json.hist.values.min-json.hist.values.max)/200);
		var xx = d3.scale.ordinal()
		   .domain(values)
		   .rangeBands([0,cells.height],0);
		
		svg.append("g")
		 .attr("id","zaxis")
		 .selectAll("rect")
		   .data(values)
		 .enter().append("rect")
		 	.attr("x", cells.x + cells.width)
			.attr("y", xx)
			.attr("height", xx.rangeBand())
			.attr("width", plotAreaMargin.right * 0.3)
			.style("fill", z)
		//	.style("fill", function(d) {/*alert(getColor(z(d))); */return getColor(z(d))});
		   
		var zz = d3.scale.linear()
		   .domain([json.hist.values.max, json.hist.values.min])
		   .range([0,cells.height]);
		
		//# linear.interpolate([factory])
		//
		//If factory is specified, sets the scale's output interpolator using the specified factory. The interpolator factory defaults to d3.interpolate, and is used to map the normalized domain parameter t in [0,1] to the corresponding value in the output range. The interpolator factory will be used to construct interpolators for each adjacent pair of values from the output range. If factory is not specified, returns the scale's interpolator factory.
		
		var zAxis = d3.svg.axis()
		    .scale(zz)
		    .tickSize(10)
		    .orient("right")
		    .tickFormat(d3.format("s"));
		var zAxisBox = document.getElementById("zaxis").getBBox();
		d3.select("#zaxis")
		.append("g")
		    .attr("class", "z axis")
		    .attr("transform", "translate("+(zAxisBox.x+zAxisBox.width)+",0)")
		    .attr("id","zaxis")
		    .call(zAxis);
	
		
		var zTitleSize = 1.5;
		var zLabelSize = 10;
		var zTicksLane = 10;
		var i;
		for (i = 0; i<5 && document.getElementById("zaxis").getBBox().width > plotAreaMargin.right; ++i) {
			    zLabelSize--;
				d3.select("#zaxis").selectAll("text")
				  .style("font-size", zLabelSize+"px")
				  .attr("x",zLabelSize+3);
				d3.select("#zaxis").selectAll(".tick")
				  .attr("x2",zLabelSize)
		}
//	if(i==5) alert("z sie nie udalo")	
	} else {
		var defWidth;
		if(!bins.width) {
		 defWidth = (json.hist.xaxis.last.value - json.hist.xaxis.first.value)/bins.content.length;
		}	 
	 	stepBins = [{x:json.hist.xaxis.first.value, y:json.hist.values.min}];
	 	var sumX = json.hist.xaxis.first.value;
	 	var stepLabels = []; 
	 	for(var i = 0; i!=bins.content.length; ++i) {
	 		stepBins.push({
	 			x: sumX,
	 			y: bins.content[i]
	 		})
	 		
	 		if(bins.width) {
	 			sumX +=  bins.width[i];
	 			if(json.hist.xaxis.labels)
	 	 			stepLabels.push(sumX);
	 		}
	 		else {
	 			sumX += defWidth;
	 		}
	 		//alert(defWidth)
	 		stepBins.push({
	 			x: sumX,
	 			y: bins.content[i]
	 		})		
	 	}
	 	
	 	stepBins.push({x:json.hist.xaxis.last.value, y:json.hist.values.min});


		var tickLen = (json.hist.xaxis.last.value - json.hist.xaxis.first.value) / bins.content.length;
		 //alert(tickLen) 
		var sum = 0;
		var line;
		var binsTable;
		//if(bins.width) {
			line = d3.svg.line()
		    .x(function(d,i) { return x(d.x);
		    	/* sum+=bins.width[i]; return xx(sum-(bins.width[i]/2));  */})
		    .y(function(d) { return y(d.y+0.000001); });
		/* } else {
			line = d3.svg.line()
		     .x(function(d,i) {return xx[i]; })
		     .y(function(d) { return y(d); });
		 } */
		var area = d3.svg.area()
		    .x(line.x())
		    .y1(line.y())
		    .y0(y(json.hist.values.min));
		
		svg.datum(stepBins);
	/*	var svg = d3.select("body").append("svg")
		    .datum(stepBins)
		    .attr("width", plotWidth)
		    .attr("height", plotHeight)
		  .append("g");*/
/*		
		if(json.hist.title) {
			var title = svg.append("g")
		 		.attr("transform","translate(" + 0 + "," + 0 + ")")
		 		.attr("id","title")
			 .append("text")
			 	.attr("class","title")
			 	.attr("dominant-baseline","hanging")
				.attr("text-anchor","begin")
			 	.text(json.hist.title);
			for(var size=2; size>=0; size-=0.1) {
				if(document.getElementById("title").getBBox().width < plotWidth)
					break;
				title.style("font-size", size+"em");			
			}
		}*/
		
		svg.append("path")
		    .attr("class", "area")
		    .attr("d", area);
		
/*		svg.append("g")
		    .attr("class", "x axis")
		    .attr("transform", "translate(0," + (plotAreaMargin.top + plotHeight)+ ")")
		    .attr("id","xaxis")
		    .call(xAxis);
		     
		svg.append("g")
		    .attr("class", "y axis")
		    .attr("id","yaxis")
		    .call(yAxis);*/
		
		svg.append("path")
		    .attr("class", "line")
		    .attr("d", line);
	}
	
	
    var titleBox = document.getElementById("title").getBBox();	
	var statsX = Math.max(titleBox.width, width)
	var statsBoxWidth = 150, statsBoxHeight = 220; 
	var statsBox = 
		main.append("g")
		 .attr("id","statsBox")
		 .attr("transform","translate(" + (svgWidth - statsBoxWidth) + "," + plotAreaMargin.top + ")")
		 .attr("display","none");

	statsBox.append("rect")
		.attr("width",statsBoxWidth)
		.attr("height",statsBoxHeight)
		.attr("fill","white")
		.attr("stroke","black")
		.attr("stroke-width", 2);
	
	statsBox.append("text")
		.text("X ")
		.attr("dominant-baseline","hanging")
		.attr("text-anchor","end")
		.attr("font-size",15)
		.attr("transform","translate("+(statsBoxWidth-2)+","+2+")")
		.attr("class","link")
		.on("click",function() {d3.select("#statsBox").attr("display","none")});
    statsBox.selectAll("tspan")

	var statsNames = statsBox.append("text")
        .attr("transform","translate("+(2)+","+18+")");
    var statsVals = statsBox.append("text")
        .attr("transform","translate("+(2)+","+18+")")
    for(var k in json.hist.stats) {
        statsNames
        .append("tspan")
         .attr("dy",15).attr("x",0)
         .text(k);        
        if( typeof json.hist.stats[k] != "object") {  
           statsVals
            .append("tspan")
//            .attr("transform","translate("+(statsBoxWidth-2)+","+20+")")
            .attr("text-anchor","end")            
            .attr("dy",15).attr("x",statsBoxWidth-5)
            .text(json.hist.stats[k]);
             
        } else {
            var wasObj = true;
            for(var axis in json.hist.stats[k]) {
                if(!wasObj) {
                    statsNames
                    .append("tspan")
                     .attr("dy",15).attr("x",0)
                     .text(" ");
                }
                wasObj = false;
                statsNames
                .append("tspan")
                 .attr("x",30)
                 .text(axis);
                var wasSubObj = true;                
                for(var vals in json.hist.stats[k][axis]) {

                    if(!wasSubObj) {
                        statsNames
                        .append("tspan")
                         .attr("dy",15).attr("x",0)
                         .text(" ");
                    }
                    wasSubObj = false;
                    statsNames
                    .append("tspan")
                     .attr("x",45)
                     .text(vals);
                    
                    statsVals
                    .append("tspan")
        //            .attr("transform","translate("+(statsBoxWidth-2)+","+20+")")
                    .attr("text-anchor","end")
                    .attr("dy",15).attr("x",statsBoxWidth-5)
                    .text(json.hist.stats[k][axis][vals]);
                }
            }
        }
    }


	
	svg
		.attr("transform", "translate(" + plotAreaMargin.left + "," + (plotAreaMargin.top) + ")");

	//.on("mouseover", function(){d3.select(this).style("background-color", "aliceblue")}) 
	//.on("mouseout", function(){d3.select(this).style("background-color", "white")}) 
	//.text(function(d,x,y){return "("+x+","+y+")->"+d;})

    var svgBox =  document.getElementsByTagName("svg")[0].getBBox();
    d3.select("content")
	 .style("width", svgBox.width+"px")
     .style("height", svgBox.height+"px")


}

function redraw() {
	alert("redraw!")
	 if(parent && parent.GUI) {
		 var extWin = parent.GUI.Plugin.DQMCanvas.getJsonWin();
		 svgWidth = extWin.getInnerWidth()-20/**0.95*/; svgHeight  =  extWin.getInnerHeight()-20/**0.95*/;
	 } else {
		 svgWidth = svgHeight = 500;
	 }
	 
	 plotAreaMargin = {top: svgHeight/10, right: svgWidth/10, bottom: svgHeight/10, left: svgWidth/10};
	 d3.select("svg").remove()
	 if(json.hist.type == "TH2" || json.hist.type == "TProfile2D" ) {

			drawTH2();
	 }
}

 var start = new Date();
 var json = JSON.parse('$JSON').list[0];
 var bins = json.hist.bins;
 var svgWidth, svgHeight;
 if(parent && parent.GUI) {
	 var extWin = parent.GUI.Plugin.DQMCanvas.getJsonWin();
	 svgWidth = extWin.getInnerWidth()-20/**0.95*/; svgHeight  =  extWin.getInnerHeight()-20/**0.95*/;
 } else {
	 svgWidth = svgHeight = 500;
 }
 
 var plotAreaMargin = {top: svgHeight/10, right: svgWidth/10, bottom: svgHeight/10, left: svgWidth/10};
 var plotWidth, plotHeight;
 var margin = {top: 20, right: 20, bottom: 20, left: 20},
 	 width = svgWidth - plotAreaMargin.left - plotAreaMargin.right,
 	 height = svgHeight - plotAreaMargin.top - plotAreaMargin.bottom;

 
	var main = d3.select("body")
	.append("div")
	 .attr("id","content")
    .append("svg")
//    .attr("width", width + margin.left + margin.right)
//    .attr("height", height + margin.top + margin.bottom)
    .attr("width", svgWidth)
    .attr("height", svgHeight)
// 
 if(json.hist.type == "TH2" || json.hist.type == "TProfile2D" ) {

		drawTH2();
 }
 
/////////////////////////////////////////////////////////////////////////////////////////////////////// 
 
 
 
 
	if(json.hist.type == "TH1" || json.hist.type == "TProfile") {

		plotAreaMargin.right = 0; 
		drawTH2();
	}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 if(json.hist.type == "THaa1") {
	var svg = main
 	   .append("g")
 	   .attr("transform", "translate(" + plotAreaMargin.left + "," + plotAreaMargin.top + ")");
	 
	var defWidth;
	if(!bins.width) {
	 defWidth = (json.hist.xaxis.last.value - json.hist.xaxis.first.value)/bins.content.length;
	}	 
 	stepBins = [{x:json.hist.xaxis.first.value, y:json.hist.values.min}];
 	var sumX = json.hist.xaxis.first.value;
 	var stepLabels = []; 
 	for(var i = 0; i!=bins.content.length; ++i) {
 		stepBins.push({
 			x: sumX,
 			y: bins.content[i]
 		})
 		
 		if(bins.width) {
 			sumX +=  bins.width[i];
 			if(json.hist.xaxis.labels)
 	 			stepLabels.push(sumX);
 		}
 		else {
 			sumX += defWidth;
 		}
 		//alert(defWidth)
 		stepBins.push({
 			x: sumX,
 			y: bins.content[i]
 		})		
 	}
 	
 	stepBins.push({x:json.hist.xaxis.last.value, y:json.hist.values.min});

	var xx = d3.scale.linear() 
	 		.domain([0,json.hist.xaxis.last.value- json.hist.xaxis.first.value])
	     	.range([0, plotWidth]);
	
	var x = d3.scale.linear() 
	      .domain([ json.hist.xaxis.first.value, 
	              json.hist.xaxis.last.value]) 
	     	.range([0, plotWidth]);
	var deltaWidth = (json.hist.values.max - json.hist.values.min)*0.025;
	if(json.hist.values.min != 0) 
		 json.hist.values.min -= deltaWidth;
	json.hist.values.max += deltaWidth;
	var y;
/*	if(json.hist.yaxis)
		if(json.hist.yaxis.scale)
			 if(json.hist.yaxis.scale == "log") {
				 y = d3.scale.log()
			     .domain([json.hist.values.min+0.000001 //to avoid log(0)... in other case dont change anything 
			              ,json.hist.values.max ])
			     .range([height, 0]);
			 } else  if (json.hist.yaxis.scale == "lin") {*/
	 y = d3.scale.linear()
	 .domain([json.hist.values.min 
	          ,json.hist.values.max ])
	 .range([plotHeight, 0]);
//			 }
		 
	
	var xAxis = d3.svg.axis()
	    .scale(x)
	    .orient("bottom");
	
	if(json.hist.xaxis.labels) {
		xAxis.ticks(bins.content.length)
	}	
	
	var yAxis = d3.svg.axis()
	    .scale(y)
	    .orient("left")
	    .tickFormat(d3.format("s"));
	
	var tickLen = (json.hist.xaxis.last.value - json.hist.xaxis.first.value) / bins.content.length;
	 //alert(tickLen) 
	var sum = 0;
	var line;
	var binsTable;
	//if(bins.width) {
		line = d3.svg.line()
	    .x(function(d,i) { return x(d.x);
	    	/* sum+=bins.width[i]; return xx(sum-(bins.width[i]/2));  */})
	    .y(function(d) { return y(d.y+0.000001); });
	/* } else {
		line = d3.svg.line()
	     .x(function(d,i) {return xx[i]; })
	     .y(function(d) { return y(d); });
	 } */
	var area = d3.svg.area()
	    .x(line.x())
	    .y1(line.y())
	    .y0(y(json.hist.values.min));
/*	var svg = d3.select("body").append("svg")
	    .datum(stepBins)
	    .attr("width", plotWidth)
	    .attr("height", plotHeight)
	  .append("g");*/
	
	if(json.hist.title) {
		var title = svg.append("g")
	 		.attr("transform","translate(" + 0 + "," + 0 + ")")
	 		.attr("id","title")
		 .append("text")
		 	.attr("class","title")
		 	.attr("dominant-baseline","hanging")
			.attr("text-anchor","begin")
		 	.text(json.hist.title);
		for(var size=2; size>=0; size-=0.1) {
			if(document.getElementById("title").getBBox().width < plotWidth)
				break;
			title.style("font-size", size+"em");			
		}
	}
	
	svg.append("path")
	    .attr("class", "area")
	    .attr("d", area);
	
	svg.append("g")
	    .attr("class", "x axis")
	    .attr("transform", "translate(0," + (plotAreaMargin.top + plotHeight)+ ")")
	    .attr("id","xaxis")
	    .call(xAxis);
	     
	svg.append("g")
	    .attr("class", "y axis")
	    .attr("id","yaxis")
	    .call(yAxis);
	
	svg.append("path")
	    .attr("class", "line")
	    .attr("d", line);
	/* 
	  svg.selectAll(".dot")
	     .data(stepBins)
	   .enter().append("circle")
	     .attr("class", "dot")
	     .attr("cx", line.x())
	     .attr("cy", line.y())
	     .attr("r", 3.5) 
	     .on("click",function(d) {alert(d.x +  " "+ d.y);}); */
	 
	
	
	if(json.hist.xaxis.labels) {
		d3.select("#xaxis").selectAll("text").remove();
		var xAxisBox = document.getElementById("xaxis").getBBox();
		var labelsPosition =  (xAxisBox.y+ xAxisBox.height);
		d3.select("#xaxis").selectAll(".label")
		.data(json.hist.xaxis.labels)
		.enter().append("text")
	  		.text(function(d) {return d.value;})
	  		.attr("class","label")
			.attr("text-anchor","begin")
			.attr("dominant-baseline","middle")  		
			.attr("transform",function(d) {return "translate("+x(d.center)+","+(labelsPosition+5)+")"/*+" rotate(30)"*/});
	}
	
	
	if(json.hist.xaxis.title) {
		var xAxisBox = document.getElementById("xaxis").getBBox();
		var xtitle = d3.select("#xaxis").append("text")
		  	.text(json.hist.xaxis.title)
			.attr("transform","translate("+(plotAreaMargin.left +plotWidth)+", "+(xAxisBox.y+ xAxisBox.height)+")")
			.attr("text-anchor","end")
			.attr("dominant-baseline","hanging")			
			.attr("id","xtitle")			
			.attr("class","axistitle")
			.attr("x",0)
			.attr("y",0);
		for(var size=1.5; size>=0; size-=0.1) {
			var xAxisBox = document.getElementById("xaxis").getBBox();
			if(xAxisBox.width < plotWidth && xAxisBox.height < plotAreaMargin.bottom)
				break;
			xtitle.style("font-size", size+"em");			
		}
	}
	if(json.hist.yaxis && json.hist.yaxis.title) {
	 	var ytitle = d3.select("#yaxis").append("text")
		  	.text(json.hist.yaxis.title)
			.attr("transform","translate("+
					(document.getElementById("yaxis").getBBox().x+10)+", 0)  rotate(90)")
			.attr("text-anchor","begin")
			.attr("dominant-baseline","hanging")
			.attr("class","axistitle")
			.attr("id","ytitle")
			.attr("x",-10)
			.attr("y",0);
		for(var size=1.5; size>=0; size-=0.1) {
			if(document.getElementById("ytitle").getBBox().width < plotHeight)
				break;
			ytitle.style("font-size", size+"em");
		}
	}

 
/*	margin.left = Math.abs(document.getElementById("yaxis").getBBox().x);
	margin.bottom = document.getElementById("xaxis").getBBox().height;
	margin.top = document.getElementById("title").getBBox().height +10;
    width = svgWidth + margin.left + margin.right,
    height = svgHeight + margin.top + margin.bottom;*/
	 //resize and move plot to show axis labels and title

	svg
		.attr("transform", "translate(" + plotAreaMargin.left + "," + plotAreaMargin.top + ")");
	/*d3.select("svg")
		.attr("width", width)
		.attr("height", height); */
 
 }

 /* 	margin = {top: 20, right: 20, bottom: 20, 
 			left: 
 			},*/

 			
 			
 			
 			
 			/* 
 			 var interpolators = {
 			   "HSL": d3.interpolateHsl,
 			   "HCL": d3.interpolateHcl,
 			   "Lab": d3.interpolateLab,
 			   "RGB": d3.interpolateRgb
 			 };

 			 var width = 960,
 			     height = 500;

 			 var y = d3.scale.ordinal()
 			     .domain(d3.keys(interpolators))
 			     .rangeRoundBands([0, height], .1);

 			 var values = d3.range(960 - 28);

 			 var x = d3.scale.ordinal()
 			     .domain(values)
 			     .rangeRoundBands([14, width - 14]);

 			 var color = d3.scale.linear()
 			     .domain([0, values.length - 1])
 			     .range(["hsl(62,100%,90%)", "hsl(228,30%,20%)"]);

 			 var svg = d3.select("body").append("svg")
 			     .attr("width", width)
 			     .attr("height", height);

 			 var g = svg.selectAll("g")
 			     .data(d3.entries(interpolators))
 			   .enter().append("g")
 			     .attr("transform", function(d) { return "translate(0," + y(d.key) + ")"; });

 			 g.each(function(d) {
 			   color.interpolate(d.value);

 			   d3.select(this).selectAll("rect")
 			     .data(values)
 			   .enter().append("rect")
 			     .attr("x", x)
 			     .attr("width", x.rangeBand())
 			     .attr("height", y.rangeBand)
 			     .style("fill", color);
 			 });

 			 g.append("text")
 			     .attr("x", 28)
 			     .attr("y", y.rangeBand() / 2)
 			     .attr("dy", ".35em")
 			     .text(function(d) { return d.key; });
 						  */ 			
 			
 			
 			
 			
</script>
</body>

<!--
function getColor(alfa) {
	var r = 255; 
	if(alfa < 0 || alfa >= 3*Math.PI/2)
		return "rgb(0,0,0)";
	if(alfa < Math.PI/2)
		return "rgb("+
				"" +Math.round(r*Math.cos(alfa)) //x
				+","+ Math.round(r*Math.sin(alfa)) // y
				+","+ 0 // z
				+")";	
	
	
	if(alfa < Math.PI)
		return "rgb("+
				"" +0
				+","+ Math.round(r*Math.cos(alfa - Math.PI/2))
				+","+ Math.round(r*Math.sin(alfa - Math.PI/2))
				+")";
	return "rgb("+			
			"" +Math.round(r*Math.sin(alfa - Math.PI))
			+","+ 0
			+","+ Math.round(r*Math.cos(alfa - Math.PI))
			+")";	
}
-->
</html>

