<!DOCTYPE html>
<meta charset="utf-8">
<html>
<style>
body {
  font: 10px sans-serif;
}

.axis path, .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.area {
  fill: lightsteelblue;
}

.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.dot {
  fill: white;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.axistitle {
	font-size: 1.5em;
	font-weight:bold;
}

.title {
	font-size: 2em;
	font-weight:bold;
}
</style>
<body>
<!--  <script src="d3\d3.v2.js"></script> -->
<!--  <script src="https://raw.github.com/mbostock/d3/master/d3.v2.js"></script> -->
<script src="http://d3js.org/d3.v2.js"></script>

<script>

var start = new Date();
 var json = JSON.parse('$JSON');
 var bins = json.hist.bins;
 var extWin = parent.GUI.Plugin.DQMCanvas.getJsonWin();
 var svgWidth = extWin.getWidth(), svgHeight  =  extWin.getHeight() ;
 
 
 var margin = {top: 20, right: 20, bottom: 20, left: 20},
 	 width = extWin.getWidth() - margin.left - margin.right,
 	 height = extWin.getHeight() - margin.top - margin.bottom;

 
 alert(extWin.getWidth() + " " +extWin.getWidth())
// alert(parent.window.height + " " + parent.document.getElementById("jsonFrame").getBBox().width)
// 
 if(json.hist.type == "TH2" || json.hist.type == "TProfile2D" ) {
	var main = d3.select("body").append("svg")
	    .attr("width", width + margin.left + margin.right)
	    .attr("height", height + margin.top + margin.bottom)
	  	    
	var titleHeight = 0;
	var titleWidth = 0;
	if(json.hist.title) {
		var title = main.append("g")
	 		.attr("transform","translate(" + 0 + "," + 0 + ")")
	 		.attr("id","title")
		 .append("text")
		 	.attr("class","title")
		 	.attr("dominant-baseline","hanging")
			.attr("text-anchor","begin")		 	
		 	.text(json.hist.title);
		for(var size=2; size>=0; size-=0.1) {
			if(document.getElementById("title").getBBox().width < width)
				break;
			title.style("font-size", size+"em");			
		}
		titleHeight = document.getElementById("title").getBBox().height
		titleWidth = document.getElementById("title").getBBox().width
	}
	statsBoxWidth = 100;
	var statsLabel = 
			main.append("g")
			 .attr("id", "stats")
			 .attr("transform","translate(" + (width) + "," + 0 + ")")
			 .on("click",function() {d3.select("#statsBox").attr("display","block")}) //
	statsLabel.append("rect")
		.attr("width",statsBoxWidth)
		.attr("height",titleHeight)
		.attr("fill","white")
		.attr("stroke","black")
		.attr("stroke-width", 2);
		
	statsLabel.append("text")
		.text("Stats")
		.attr("dominant-baseline","middle")
		.attr("text-anchor","middle")
		.attr("transform","translate("+statsBoxWidth/2+","+titleHeight/2+")");
		
	if(document.getElementById("title").getBBox().height == 0)
		titleHeight = document.getElementById("stats").getBBox().height;

	var svg = main
		 	   .append("g")
		       .attr("transform", "translate(" + margin.left + "," + (margin.top + titleHeight) + ")");
	
	var x = d3.scale.linear() 
      .domain([ json.hist.xaxis.first.value, 
              json.hist.xaxis.last.value]) 
     	.range([0, width]);
	var deltaWidth = (json.hist.values.max - json.hist.values.min)*0.025;
/*	if(json.hist.values.min != 0) 
		 json.hist.values.min -= deltaWidth;
	json.hist.values.max += deltaWidth;*/
//	var y;
/*	if(json.hist.yaxis)
		if(json.hist.yaxis.scale)
			 if(json.hist.yaxis.scale == "log") {
				 y = d3.scale.log()
			     .domain([json.hist.values.min+0.000001 //to avoid log(0)... in other case dont change anything 
			              ,json.hist.values.max ])
			     .range([height, 0]);
			 } else if (json.hist.yaxis.scale == "lin") {*/
 var y = d3.scale.linear()
 .domain([json.hist.yaxis.first.value
          ,json.hist.yaxis.last.value])
 .range([height, 0]);
 

//			 }	  

 	var nXbins = bins.content[0].length,
		nYbins = bins.content.length;
	
	var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");

	if(json.hist.xaxis.labels) {
		xAxis.ticks(nXbins);
	} else {
		xAxis.tickFormat(d3.format("s"));
	}
	var yAxis = d3.svg.axis()
	    .scale(y)
	    .orient("left");
	
	if(json.hist.yaxis.labels) {
		yAxis.ticks(nYbins);
	} else {
		yAxis.tickFormat(d3.format("s"));
	}
	
	svg.append("g")
	    .attr("class", "x axis")
	    .attr("transform", "translate(0," + height + ")")
	    .attr("id","xaxis")
	    .call(xAxis);
	     
	svg.append("g")
	    .attr("class", "y axis")
	    .attr("id","yaxis")
	    .call(yAxis);	
	//nXbins
	if(json.hist.xaxis.labels) {
		d3.select("#xaxis").selectAll("text").remove();
		var xAxisBox = document.getElementById("xaxis").getBBox();
		var labelsPosition =  (xAxisBox.y+ xAxisBox.height);
		d3.select("#xaxis").selectAll(".label")
		.data(json.hist.xaxis.labels)
		.enter().append("text")
	  		.text(function(d) {return d.value;})
	  		.attr("class","label")
			.attr("text-anchor","begin")
			.attr("dominant-baseline","middle")  		
			.attr("transform",function(d) {return "translate("+x(d.center)+","+(labelsPosition+5)+")"+" rotate(30)"});
	}
	 
	if(json.hist.yaxis.labels) {
		d3.select("#yaxis").selectAll("text").remove();
		var labelsPosition =  (document.getElementById("yaxis").getBBox().x);
		d3.select("#yaxis").selectAll(".label")
		.data(json.hist.yaxis.labels)
		.enter().append("text")
	  		.text(function(d) {return d.value;})
	  		.attr("class","label")
			.attr("text-anchor","end")
			.attr("dominant-baseline","middle")  		
			.attr("transform",function(d) {return "translate("+(labelsPosition-5)+","+y(d.center)+")"+" rotate(0)"});
	} 
	
	if(json.hist.xaxis.title) {
		var xAxisBox = document.getElementById("xaxis").getBBox();
		var xtitle = d3.select("#xaxis").append("text")
		  	.text(json.hist.xaxis.title)
			.attr("transform","translate("+width+", "+(xAxisBox.y+ xAxisBox.height)+")")
			.attr("text-anchor","end")
			.attr("dominant-baseline","hanging")			
			.attr("id","xtitle")			
			.attr("class","axistitle")
			.attr("x",0)
			.attr("y",0);
		for(var size=1.5; size>=0; size-=0.1) {
			if(document.getElementById("xtitle").getBBox().width < width)
				break;
			xtitle.style("font-size", size+"em");			
		}
	}
	if(json.hist.yaxis.title) {
	 	var ytitle = d3.select("#yaxis").append("text")
		  	.text(json.hist.yaxis.title)
			.attr("transform","translate("+
					document.getElementById("yaxis").getBBox().x+", 0)  rotate(90)")
			.attr("text-anchor","begin")
			.attr("dominant-baseline","hanging")
			.attr("class","axistitle")
			.attr("id","ytitle")
			.attr("x",-10)
			.attr("y",0);
		for(var size=1.5; size>=0; size-=0.1) {
			if(document.getElementById("ytitle").getBBox().width < height)
				break;
			ytitle.style("font-size", size+"em");
		}
	}

	function getColor(alfa) {
		var r = 255; 
		if(alfa < 0 || alfa >= 3*Math.PI/2)
			return "rgb(0,0,0)";
		if(alfa < Math.PI/2)
			return "rgb("+
					"" +Math.round(r*Math.cos(alfa)) //x
					+","+ Math.round(r*Math.sin(alfa)) // y
					+","+ 0 // z
					+")";	
		
		
		if(alfa < Math.PI)
			return "rgb("+
					"" +0
					+","+ Math.round(r*Math.cos(alfa - Math.PI/2))
					+","+ Math.round(r*Math.sin(alfa - Math.PI/2))
					+")";
		return "rgb("+			
				"" +Math.round(r*Math.sin(alfa - Math.PI))
				+","+ 0
				+","+ Math.round(r*Math.cos(alfa - Math.PI))
				+")";	
	}

	var range = (json.hist.values.max-json.hist.values.min);
	var min = json.hist.values.min;
	var z = d3.scale.linear()
	   .domain([min, min+range/5, min+2*range/5, min+3*range/5, min+4*range/5,  json.hist.values.max])
//	   .range(["blue","green","red"])
	   .range(["rgb(255,0,255)","rgb(0,0,255)","rgb(0,255,255)", "rgb(0,255,0)","rgb(255,255,0)", "rgb(255,0,0)"])
//	   .range(["rgb(255,0,0)","rgb(255,255,0)", "rgb(0,255,0)","rgb(0,255,255)","rgb(0,0,255)"])
	   .interpolate(d3.interpolateRgb);
/*	var z = d3.scale.linear()
		 .domain([json.hist.values.min, json.hist.values.max])
		 .range([Math.PI,0]);*/

	
	
	var stepsX=[json.hist.xaxis.first.value], stepsY=[json.hist.yaxis.first.value], 
		defWidthX, defWidthY,
		sumX = json.hist.xaxis.first.value, sumY = json.hist.yaxis.first.value,
		defRectWidth, defRectHeight,
		yDefWidth,xDefWidth;

	if(bins.widthX)
	 	for(var i = 0; i!=nXbins; ++i) { 
			sumX += bins.widthX[i];
	 		stepsX.push(sumX);
	 	}
	 else {
		 
		 defWidthX = (json.hist.xaxis.last.value - json.hist.xaxis.first.value)/nXbins;
		 defRectWidth = x(json.hist.xaxis.first.value+defWidthX) - x(json.hist.xaxis.first.value)
		 xDefWidth = d3.scale.linear() 
		      .domain([ 0, 
		              (json.hist.xaxis.last.value- json.hist.xaxis.first.value)/defWidthX]) 
		     	.range([0, width]);
	 }
	if(bins.widthY)	 		
	 	for(var i = 0; i!=nYbins; ++i) {
			sumY +=  bins.widthY[i];
	 		stepsY.push(sumY)
	 	}
	else {
		defWidthY = (json.hist.yaxis.last.value - json.hist.yaxis.first.value)/nYbins;
		defRectHeight = y(json.hist.yaxis.first.value)-y(json.hist.yaxis.first.value+defWidthY);
//		 var y = d3.scale.linear()
//		 .domain([json.hist.yaxis.first.value
//		          ,json.hist.yaxis.last.value])
//		 .range([height, 0]);
		yDefWidth = d3.scale.linear()
		 .domain([0
		          ,(json.hist.yaxis.last.value- json.hist.yaxis.first.value)/defWidthY])
//		 .range([defWidthY*(height-defRectHeight+json.hist.yaxis.first.value), defWidthY*(defRectHeight+json.hist.yaxis.first.value)]);
		 .range([height-defRectHeight, -defRectHeight]);        
	}
	
	var rects = svg
	  .append("g")
	   .attr("id","cells")
	   .selectAll(".row")
	   .data(bins.content)
	   .enter()
      .append("g")
	   .attr("id","row")
	   .selectAll(".point")
	   .data(function(d){return d;})
	   .enter()
	  .append("rect")
	   .attr("id","point")
	   .style("fill",function(d,i,j) {if(d==0) {return "rgb(255,255,255)";} else {return z(d);}});
//	.style("fill",function(d,i,j) {if(d==0) {return "rgb(255,255,255)";} else {return getColor(z(d));}});
	if(bins.widthX)
		rects
		 .attr("x",function(d,i,j) {return x(stepsX[i]); })
		 .attr("width",function(d,i,j) {return x(bins.widthX[i]+ json.hist.xaxis.first.value);})
	else 
		rects
		 .attr("x",function(d,i,j) {return xDefWidth(i);})
		 .attr("width",defRectWidth)
		
		
	if(bins.widthY)
		rects
		 .attr("y",function(d,i,j) {return y(stepsY[j]);})
	     .attr("height",function(d,j,i) {return y(json.hist.yaxis.last.value- bins.widthY[j]);})	 
	else
		rects
		 .attr("y",function(d,i,j) {return yDefWidth(j);})
		 .attr("height",defRectHeight)		
		
		/*
		
		.attr("y",function(d,i,j) {if(bins.widthY) return y(stepsY[i]); else return yDefWidth(j);})
//       .attr("x",function(d,j,i) {if(bins.widthX) return x(stepsX[j]); else return x(j*defWidthX + json.hist.xaxis.first.value);})
	   .attr("x",function(d,i,j) {if(bins.widthX) return x(stepsX[j]); else return xDefWidth(i);})
//	   .attr("y",function(d,j,i) {if(bins.widthY) return y(stepsY[i]); else return y(i*defWidthY + json.hist.yaxis.first.value)-defRectHeight;})
	   .attr("y",function(d,i,j) {if(bins.widthY) return y(stepsY[i]); else return yDefWidth(j);})
//	   .attr("y", yy)
//	   .attr("width",function(d,j,i) {if(bins.widthX) return x(bins.widthX[j]+ json.hist.xaxis.first.value); else return defRectWidth;})
//	   .attr("height",function(d,j,i) {if(bins.widthY) {return y(json.hist.yaxis.last.value- bins.widthY[i]);} else return defRectHeight;})
	   .attr("width",defRectWidth)
	   .attr("height",defRectHeight)*/
	   
	var cells = document.getElementById("cells").getBBox();
	var values = d3.range(json.hist.values.max, json.hist.values.min, (json.hist.values.min-json.hist.values.max)/200);
	var xx = d3.scale.ordinal()
	   .domain(values)
	   .rangeBands([0,cells.height],0);

	svg.append("g")
	 .attr("id","zaxis")
	 .selectAll("rect")
	   .data(values)
	 .enter().append("rect")
	 	.attr("x", 10+cells.x + cells.width)
		.attr("y", xx)
		.attr("height", xx.rangeBand())
		.attr("width", 20)
		.style("fill", z)
//		.style("fill", function(d) {/*alert(getColor(z(d))); */return getColor(z(d))});
	   
	var zz = d3.scale.linear()
	   .domain([json.hist.values.max, json.hist.values.min])
	   .range([0,cells.height]);
	
//	# linear.interpolate([factory])
//
//	If factory is specified, sets the scale's output interpolator using the specified factory. The interpolator factory defaults to d3.interpolate, and is used to map the normalized domain parameter t in [0,1] to the corresponding value in the output range. The interpolator factory will be used to construct interpolators for each adjacent pair of values from the output range. If factory is not specified, returns the scale's interpolator factory.
	
	var zAxis = d3.svg.axis()
	    .scale(zz)
	    .tickSize(10)
	    .orient("right")
	    .tickFormat(d3.format("s"));
	var zAxisBox = document.getElementById("zaxis").getBBox();
	d3.select("#zaxis")
	.append("g")
	    .attr("class", "z axis")
	    .attr("transform", "translate("+(zAxisBox.x+zAxisBox.width)+",0)")
	    .attr("id","zaxis")
	    .call(zAxis);

	
	var statsBox = 
		main.append("g")
		 .attr("id","statsBox")
		 .attr("transform","translate(" + (width) + "," + titleHeight + ")")
		 .attr("display","none");

	statsBox.append("rect")
		.attr("width",100)
		.attr("height",200)
		.attr("fill","white")
		.attr("stroke","black")
		.attr("stroke-width", 2);
		
	statsBox.append("text")
		.text("X ")
		.attr("dominant-baseline","hanging")
		.attr("text-anchor","end")
		.attr("font-size",15)
		.attr("transform","translate("+(100-2)+","+0+")")
		.on("click",function() {d3.select("#statsBox").attr("display","none")});	
	
	
	var dictNames = new Object();
	
	
	margin.left = Math.abs(document.getElementById("yaxis").getBBox().x);
	margin.bottom = document.getElementById("xaxis").getBBox().height;
	margin.right = document.getElementById("zaxis").getBBox().width;
    width = svgWidth + margin.left + margin.right,
    height = svgHeight + margin.top + margin.bottom;
	 //resize and move plot to show axis labels and title

	svg
		.attr("transform", "translate(" + margin.left + "," + (margin.top + document.getElementById("title").getBBox().height) + ")");
	d3.select("svg")
		.attr("width", width)
		.attr("height", height); 
//    .on("mouseover", function(){d3.select(this).style("background-color", "aliceblue")}) 
//    .on("mouseout", function(){d3.select(this).style("background-color", "white")}) 
    //.text(function(d,x,y){return "("+x+","+y+")->"+d;})

	

		
 }
 
/////////////////////////////////////////////////////////////////////////////////////////////////////// 
 
 if(json.hist.type == "TH1") {
	var defWidth;
	if(!bins.width) {
	 defWidth = (json.hist.xaxis.last.value - json.hist.xaxis.first.value)/bins.content.length;
	}	 
 	stepBins = [{x:json.hist.xaxis.first.value, y:json.hist.values.min}];
 	var sumX = json.hist.xaxis.first.value;
 	var stepLabels = []; 
 	for(var i = 0; i!=bins.content.length; ++i) {
 		stepBins.push({
 			x: sumX,
 			y: bins.content[i]
 		})
 		
 		if(bins.width) {
 			sumX +=  bins.width[i];
 			if(json.hist.xaxis.labels)
 	 			stepLabels.push(sumX);
 		}
 		else {
 			sumX += defWidth;
 		}
 		//alert(defWidth)
 		stepBins.push({
 			x: sumX,
 			y: bins.content[i]
 		})		
 	}
 	
 	stepBins.push({x:json.hist.xaxis.last.value, y:json.hist.values.min});

	var xx = d3.scale.linear() 
	 		.domain([0,json.hist.xaxis.last.value- json.hist.xaxis.first.value])
	     	.range([0, width]);
	
	var x = d3.scale.linear() 
	      .domain([ json.hist.xaxis.first.value, 
	              json.hist.xaxis.last.value]) 
	     	.range([0, width]);
	var deltaWidth = (json.hist.values.max - json.hist.values.min)*0.025;
	if(json.hist.values.min != 0) 
		 json.hist.values.min -= deltaWidth;
	json.hist.values.max += deltaWidth;
	var y;
/*	if(json.hist.yaxis)
		if(json.hist.yaxis.scale)
			 if(json.hist.yaxis.scale == "log") {
				 y = d3.scale.log()
			     .domain([json.hist.values.min+0.000001 //to avoid log(0)... in other case dont change anything 
			              ,json.hist.values.max ])
			     .range([height, 0]);
			 } else  if (json.hist.yaxis.scale == "lin") {*/
	 y = d3.scale.linear()
	 .domain([json.hist.values.min 
	          ,json.hist.values.max ])
	 .range([height, 0]);
//			 }
		 
	
	var xAxis = d3.svg.axis()
	    .scale(x)
	    .orient("bottom");
	
	if(json.hist.xaxis.labels) {
		xAxis.ticks(bins.content.length)
	}	
	
	var yAxis = d3.svg.axis()
	    .scale(y)
	    .orient("left")
	    .tickFormat(d3.format("s"));
	
	var tickLen = (json.hist.xaxis.last.value - json.hist.xaxis.first.value) / bins.content.length;
	 //alert(tickLen) 
	var sum = 0;
	var line;
	var binsTable;
	//if(bins.width) {
		line = d3.svg.line()
	    .x(function(d,i) { return x(d.x);
	    	/* sum+=bins.width[i]; return xx(sum-(bins.width[i]/2));  */})
	    .y(function(d) { return y(d.y+0.000001); });
	/* } else {
		line = d3.svg.line()
	     .x(function(d,i) {return xx[i]; })
	     .y(function(d) { return y(d); });
	 } */
	var area = d3.svg.area()
	    .x(line.x())
	    .y1(line.y())
	    .y0(y(json.hist.values.min));
	var svg = d3.select("body").append("svg")
	    .datum(stepBins)
	    .attr("width", width + margin.left + margin.right)
	    .attr("height", height + margin.top + margin.bottom)
	  .append("g")
	    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	
	if(json.hist.title) {
		var title = svg.append("g")
	 		.attr("transform","translate(" + 0 + "," + -margin.top + ")")
	 		.attr("id","title")
		 .append("text")
		 	.attr("class","title")
		 	.attr("dominant-baseline","hanging")
			.attr("text-anchor","begin")		 	
		 	.text(json.hist.title);
		for(var size=2; size>=0; size-=0.1) {
			if(document.getElementById("title").getBBox().width < width)
				break;
			title.style("font-size", size+"em");			
		}
	}
	
	svg.append("path")
	    .attr("class", "area")
	    .attr("d", area);
	
	svg.append("g")
	    .attr("class", "x axis")
	    .attr("transform", "translate(0," + height + ")")
	    .attr("id","xaxis")
	    .call(xAxis);
	     
	svg.append("g")
	    .attr("class", "y axis")
	    .attr("id","yaxis")
	    .call(yAxis);
	
	svg.append("path")
	    .attr("class", "line")
	    .attr("d", line);
	/* 
	  svg.selectAll(".dot")
	     .data(stepBins)
	   .enter().append("circle")
	     .attr("class", "dot")
	     .attr("cx", line.x())
	     .attr("cy", line.y())
	     .attr("r", 3.5) 
	     .on("click",function(d) {alert(d.x +  " "+ d.y);}); */
	 
	
	
	if(json.hist.xaxis.labels) {
		d3.select("#xaxis").selectAll("text").remove();
		var xAxisBox = document.getElementById("xaxis").getBBox();
		var labelsPosition =  (xAxisBox.y+ xAxisBox.height);
		d3.select("#xaxis").selectAll(".label")
		.data(json.hist.xaxis.labels)
		.enter().append("text")
	  		.text(function(d) {return d.value;})
	  		.attr("class","label")
			.attr("text-anchor","begin")
			.attr("dominant-baseline","middle")  		
			.attr("transform",function(d) {return "translate("+x(d.center)+","+(labelsPosition+5)+")"+" rotate(30)"});
	}
	
	
	if(json.hist.xaxis.title) {
		var xAxisBox = document.getElementById("xaxis").getBBox();
		var xtitle = d3.select("#xaxis").append("text")
		  	.text(json.hist.xaxis.title)
			.attr("transform","translate("+width+", "+(xAxisBox.y+ xAxisBox.height)+")")
			.attr("text-anchor","end")
			.attr("dominant-baseline","hanging")			
			.attr("id","xtitle")			
			.attr("class","axistitle")
			.attr("x",0)
			.attr("y",0);
		for(var size=1.5; size>=0; size-=0.1) {
			if(document.getElementById("xtitle").getBBox().width < width)
				break;
			xtitle.style("font-size", size+"em");			
		}
	}
	if(json.hist.yaxis && json.hist.yaxis.title) {
	 	var ytitle = d3.select("#yaxis").append("text")
		  	.text(json.hist.yaxis.title)
			.attr("transform","translate("+
					document.getElementById("yaxis").getBBox().x+", 0)  rotate(90)")
			.attr("text-anchor","begin")
			.attr("dominant-baseline","hanging")
			.attr("class","axistitle")
			.attr("id","ytitle")
			.attr("x",-10)
			.attr("y",0);
		for(var size=1.5; size>=0; size-=0.1) {
			if(document.getElementById("ytitle").getBBox().width < height)
				break;
			ytitle.style("font-size", size+"em");
		}	 	
	}

 
	margin.left = Math.abs(document.getElementById("yaxis").getBBox().x);
	margin.bottom = document.getElementById("xaxis").getBBox().height;
	margin.top = document.getElementById("title").getBBox().height +10;
    width = svgWidth + margin.left + margin.right,
    height = svgHeight + margin.top + margin.bottom;
	 //resize and move plot to show axis labels and title

	svg
		.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	d3.select("svg")
		.attr("width", width)
		.attr("height", height); 
 
 }

 /* 	margin = {top: 20, right: 20, bottom: 20, 
 			left: 
 			},*/

 			
 			
 			
 			
 			/* 
 			 var interpolators = {
 			   "HSL": d3.interpolateHsl,
 			   "HCL": d3.interpolateHcl,
 			   "Lab": d3.interpolateLab,
 			   "RGB": d3.interpolateRgb
 			 };

 			 var width = 960,
 			     height = 500;

 			 var y = d3.scale.ordinal()
 			     .domain(d3.keys(interpolators))
 			     .rangeRoundBands([0, height], .1);

 			 var values = d3.range(960 - 28);

 			 var x = d3.scale.ordinal()
 			     .domain(values)
 			     .rangeRoundBands([14, width - 14]);

 			 var color = d3.scale.linear()
 			     .domain([0, values.length - 1])
 			     .range(["hsl(62,100%,90%)", "hsl(228,30%,20%)"]);

 			 var svg = d3.select("body").append("svg")
 			     .attr("width", width)
 			     .attr("height", height);

 			 var g = svg.selectAll("g")
 			     .data(d3.entries(interpolators))
 			   .enter().append("g")
 			     .attr("transform", function(d) { return "translate(0," + y(d.key) + ")"; });

 			 g.each(function(d) {
 			   color.interpolate(d.value);

 			   d3.select(this).selectAll("rect")
 			     .data(values)
 			   .enter().append("rect")
 			     .attr("x", x)
 			     .attr("width", x.rangeBand())
 			     .attr("height", y.rangeBand)
 			     .style("fill", color);
 			 });

 			 g.append("text")
 			     .attr("x", 28)
 			     .attr("y", y.rangeBand() / 2)
 			     .attr("dy", ".35em")
 			     .text(function(d) { return d.key; });
 						  */ 			
 			
 			
 			
 			
</script>
</body>
</html>


